{"componentChunkName":"component---node-modules-gatsby-theme-garden-src-templates-local-file-js","path":"/Static Method","result":{"data":{"file":{"childMdx":{"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"static-methods\"\n  }, \"Static Methods\"), mdx(\"p\", null, \"A static method\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"belongs to the class rather than the object of a class.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"can be invoked without the need for creating an instance of a class.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"can access static data member and can change the value of it.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"cannot be abstract because they can't be overridden.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/Static-Methods-can't-access-instance(non-static)-variables\",\n    \"title\": \"Static Methods can't access instance(non-static) variables\"\n  }, \"[[Static Methods can't access instance(non-static) variables]]\"), \"\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/Overriding-static-methods\",\n    \"title\": \"Overriding static methods\"\n  }, \"[[Overriding static methods]]\"), \"\")));\n}\n;\nMDXContent.isMDXComponent = true;","outboundReferences":[{"__typename":"Mdx","body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"static-methods-cant-access-instancenon-static-variables\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"h1\",\n    \"href\": \"/Static-Method\",\n    \"title\": \"Static Method\"\n  }, \"[[Static Method]]\"), \"s can't access instance(non-static) variables\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-java\"\n  }, \"class A{\\n    int x;\\n    public static void func(){\\n        x++; //Error\\n    }\\n}\\n\")), mdx(\"p\", null, \"When you right this, the method doesn't know which 'x' to call. In case of a non-static method, it is understood that its this.x - it is implicit. But in static context, there is no 'this'.\"), mdx(\"p\", null, \"However, if you tell it the object, it can work. But again, this object will be static.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-java\"\n  }, \"class A{\\n    int x;\\n    static A a = new A(); //static object\\n    public static void func(){\\n    a.x++; //Works fine\\n    }\\n}\\n\")));\n}\n;\nMDXContent.isMDXComponent = true;","frontmatter":{"aliases":[]},"parent":{"__typename":"File","id":"cbf399a8-658a-5a29-a059-7b427c863237","fields":{"slug":"/Static Methods can't access instance(non-static) variables","title":"[[Static Method]]s can't access instance(non-static) variables"}}},{"__typename":"Mdx","body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }));\n}\n;\nMDXContent.isMDXComponent = true;","frontmatter":{"aliases":[]},"parent":{"__typename":"File","id":"54ac2dd4-a945-5f91-8f04-8befe52ab61b","fields":{"slug":"/Overriding static methods","title":"Overriding static methods"}}}],"inboundReferences":[{"__typename":"Mdx","body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"static\"\n  }, \"Static\"), mdx(\"h2\", {\n    \"id\": \"ownership\"\n  }, \"Ownership\"), mdx(\"p\", null, \"Static members and methods are owned by the class itself, not any object.\"), mdx(\"h2\", {\n    \"id\": \"accessing\"\n  }, \"Accessing\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"You don't need to create an instance or object to access static members.\"), mdx(\"p\", {\n    parentName: \"li\"\n  }, \"  You can access them through class.\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/Accessing-Static-members-using-objects\",\n    \"title\": \"Accessing Static members using objects\"\n  }, \"[[Accessing Static members using objects]]\"), \"\"))), mdx(\"h2\", {\n    \"id\": \"initialization-in-program-memory\"\n  }, \"Initialization in program memory\"), mdx(\"p\", null, \"Static members are loaded into program memory along with the class. Even before initializing any objects.\"), mdx(\"h2\", {\n    \"id\": \"static-stuff\"\n  }, \"Static stuff\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/Static-Variable\",\n    \"title\": \"Static Variable\"\n  }, \"[[Static Variable]]\"), \"\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/Static-Method\",\n    \"title\": \"Static Method\"\n  }, \"[[Static Method]]\"), \"\")));\n}\n;\nMDXContent.isMDXComponent = true;","parent":{"__typename":"File","id":"74129eb0-ec7c-543b-90a6-646352220b79","fields":{"slug":"/Static","title":"Static"}}},{"__typename":"Mdx","body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"static-methods-cant-be-overridden\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"h1\",\n    \"href\": \"/Static-Method\",\n    \"title\": \"Static Method\"\n  }, \"[[Static Method]]\"), \"s can't be overridden\"), mdx(\"p\", null, \"You can't.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-java\"\n  }, \"//Can't do this -> Compile time error\\nclass Foo {\\n    public static void method() {\\n        System.out.println(\\\"in Foo\\\");\\n    }\\n}\\n \\nclass Bar extends Foo {\\n    public void method() {\\n        System.out.println(\\\"in Bar\\\");\\n    }\\n}\\n\")), mdx(\"p\", null, \"\", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/Why-compiler-sometimes-talks-about-overriding-static-methods\",\n    \"title\": \"Why compiler sometimes talks about overriding static methods\"\n  }, \"[[Why compiler sometimes talks about overriding static methods]]\"), \"\"));\n}\n;\nMDXContent.isMDXComponent = true;","parent":{"__typename":"File","id":"21b37855-cb1c-5d72-aaf6-824c6808b7d8","fields":{"slug":"/Static Methods can't be overridden","title":"[[Static Method]]s can't be overridden"}}},{"__typename":"Mdx","body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"skip-validations-while-creating-se\"\n  }, \"Skip Validations while creating SE\"), mdx(\"p\", null, \"For certain use cases, validations are skipped during \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/Service-Execution-Creation\",\n    \"title\": \"Service Execution Creation\"\n  }, \"[[Service Execution Creation]]\"), \".\"), mdx(\"p\", null, \"This is taken care of by the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"/A1SSPC/CL_SE_SKIP_VALIDATION\"), \" API which is a \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/Singleton\",\n    \"title\": \"Singleton\"\n  }, \"[[Singleton]]\"), \" class (kind of - the constructor is not private).\"), mdx(\"p\", null, \"The class has a flag \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"mv_skip_validation_toggle\"), \" which tells whether validations are to be skipped or not. Since the flag has to be checked from multiple places, once set, it should hold that value consistently. This is why the class needs to be a singleton.\"), mdx(\"p\", null, \"The singleton instance \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"mo_skip_validation\"), \" is fetched using \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"get_instance\"), \" \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/Static-Method\",\n    \"title\": \"Static Method\"\n  }, \"[[Static Method]]\"), \".\"), mdx(\"p\", null, \"After that you can use \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"activate_validation\"), \" or \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"deactivate_validation\"), \" method to either toggle the switch on and off or you check if the flag is on using \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"is_skip_validation_active\"), \" method.\"), mdx(\"p\", null, \"Example:\"), mdx(\"p\", null, \"From \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/Service-Execution-Creation-API\",\n    \"title\": \"Service Execution Creation API\"\n  }, \"[[Service Execution Creation API]]\"), \" \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"/A1SSPC/IF_HANDLE_REQUEST~CREATE_FOLLOW_UP_OBJS\"), \" line 18\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-abap\"\n  }, \"/a1sspc/cl_se_skip_validation->get_instance( )->activate_validation( ).\\n\")), mdx(\"h2\", {\n    \"id\": \"references\"\n  }, \"References\"));\n}\n;\nMDXContent.isMDXComponent = true;","parent":{"__typename":"File","id":"4532473a-2ab6-56c1-8b00-7d640aff4cef","fields":{"slug":"/Skip Validations while creating SE","title":"Skip Validations while creating SE"}}},{"__typename":"Mdx","body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"static-methods-cant-access-instancenon-static-variables\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"h1\",\n    \"href\": \"/Static-Method\",\n    \"title\": \"Static Method\"\n  }, \"[[Static Method]]\"), \"s can't access instance(non-static) variables\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-java\"\n  }, \"class A{\\n    int x;\\n    public static void func(){\\n        x++; //Error\\n    }\\n}\\n\")), mdx(\"p\", null, \"When you right this, the method doesn't know which 'x' to call. In case of a non-static method, it is understood that its this.x - it is implicit. But in static context, there is no 'this'.\"), mdx(\"p\", null, \"However, if you tell it the object, it can work. But again, this object will be static.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-java\"\n  }, \"class A{\\n    int x;\\n    static A a = new A(); //static object\\n    public static void func(){\\n    a.x++; //Works fine\\n    }\\n}\\n\")));\n}\n;\nMDXContent.isMDXComponent = true;","parent":{"__typename":"File","id":"cbf399a8-658a-5a29-a059-7b427c863237","fields":{"slug":"/Static Methods can't access instance(non-static) variables","title":"[[Static Method]]s can't access instance(non-static) variables"}}},{"__typename":"Mdx","body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"static-in-java\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"h1\",\n    \"href\": \"/Static\",\n    \"title\": \"Static\"\n  }, \"[[Static]]\"), \" in Java\"), mdx(\"h2\", {\n    \"id\": \"example-of-class-containing-static-members\"\n  }, \"Example of class containing static members\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-java\"\n  }, \"public class Example\\n{\\nint x; // Instance variable\\nstatic int y; // Static member variable\\n\\npublic void fun() { static int a; } // Instance member function\\npublic static void fun2() { } // Static member function \\n\\nstatic class Test //Static inner class\\n{ }\\n}\\n\")), mdx(\"h2\", {\n    \"id\": \"static-variables\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"/Static-Variable\",\n    \"title\": \"Static Variable\"\n  }, \"[[Static Variable]]\"), \"s\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Initialization\"), mdx(\"p\", {\n    parentName: \"li\"\n  }, \"  Values can be assigned in special static initializer blocks / \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/static-Blocks\",\n    \"title\": \"static Blocks\"\n  }, \"[[static Blocks]]\"), \"\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Accessing\"), mdx(\"p\", {\n    parentName: \"li\"\n  }, \"  Accessing outside class - \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ClassName.VariableName\"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Naming\"), mdx(\"p\", {\n    parentName: \"li\"\n  }, \"  When declaring class variables as public static final, then variable names (constants) are all in upper case. If the static variables are not final, the naming syntax is the same as instance and local variables.\"))), mdx(\"h2\", {\n    \"id\": \"static-blocks\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"/Static-Blocks\",\n    \"title\": \"Static Blocks\"\n  }, \"[[Static Blocks]]\"), \"\"), mdx(\"h2\", {\n    \"id\": \"static-methods\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"/Static-Method\",\n    \"title\": \"Static Method\"\n  }, \"[[Static Method]]\"), \"s\"), mdx(\"h2\", {\n    \"id\": \"static-class\"\n  }, \"Static class\"), mdx(\"p\", null, \"\", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/Static-Inner-Class\",\n    \"title\": \"Static Inner Class\"\n  }, \"[[Static Inner Class]]\"), \"\"));\n}\n;\nMDXContent.isMDXComponent = true;","parent":{"__typename":"File","id":"061e5004-60bd-5c1d-a587-390089b739ab","fields":{"slug":"/Static in Java","title":"[[Static]] in Java"}}}]},"fields":{"slug":"/Static Method","title":"Static Methods"}}},"pageContext":{"id":"86ceb8bc-89dd-580c-9ea0-5375f836dcef"}},"staticQueryHashes":["2098632890","2221750479","2468095761"]}