{"componentChunkName":"component---node-modules-gatsby-theme-garden-src-templates-local-file-js","path":"/Runtime Polymorphism -- When you override - you get it -- when you hide - you don't","result":{"data":{"file":{"childMdx":{"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"runtime-polymorphism-or-dynamic-method-dispatch----when-you-override---you-get-it----when-you-hide---you-dont\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"h1\",\n    \"href\": \"/Runtime-Polymorphism-or-Dynamic-Method-Dispatch\",\n    \"title\": \"Runtime Polymorphism or Dynamic Method Dispatch\"\n  }, \"[[Runtime Polymorphism or Dynamic Method Dispatch]]\"), \" -- When you override - you get it -- when you hide - you don't\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-java\"\n  }, \"class Foo {\\n    public static void classMethod() {\\n        System.out.println(\\\"classMethod() in Foo\\\");\\n    }\\n \\n    public void instanceMethod() {\\n        System.out.println(\\\"instanceMethod() in Foo\\\");\\n    }\\n}\\n \\nclass Bar extends Foo {\\n    public static void classMethod() {\\n        System.out.println(\\\"classMethod() in Bar\\\");\\n    }\\n \\n    public void instanceMethod() {\\n        System.out.println(\\\"instanceMethod() in Bar\\\");\\n    }\\n}\\n  \\npublic class Test {\\n    public static void main(String[] args) {\\n        Foo f = new Bar();\\n        f.instanceMethod();\\n        f.classMethod(); //*Accessing static method using object\\n    }\\n}\\n\")), mdx(\"p\", null, \"Output -\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-java\"\n  }, \"instanceMethod() in Bar\\nclassMethod() in Foo\\n\")), mdx(\"p\", null, \"We are using the same instance to access both the methods. But since one is overriding and the other is hiding, we see different behaviours.\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"In case of instance method-\"), mdx(\"p\", {\n    parentName: \"li\"\n  }, \"  At runtime, JVM uses the instance 'f' to determine which method to run.\"), mdx(\"p\", {\n    parentName: \"li\"\n  }, \"  JVM sees at runtime, that 'f' is actually an instance of Bar, so it calls the method in Bar rather than the one in Foo.\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"In case of class (static) method-\"), mdx(\"p\", {\n    parentName: \"li\"\n  }, \"  Since, its a static method, JVM doesn't expect or need any instance to invoke that method. Even if you provide it with an instance like we did here, it will simply ignore it. It will just see the declaration of that instance, determine the declared type of it to determine which method to call. All of this, at compile-time.\"), mdx(\"p\", {\n    parentName: \"li\"\n  }, \"  It doesn't matter when at runtime, its decided that f is actually an instance of Bar. That's what we mean when we say a static method does not have run-time polymorphism.\"), mdx(\"p\", {\n    parentName: \"li\"\n  }, \"  Because of this difference in behaviour in static and instance methods, we use different terms - \\\"overriding\\\" for instance methods and \\\"hiding\\\" for class methods.\"), mdx(\"p\", {\n    parentName: \"li\"\n  }, \"  And when we say, you can't override a static method, it means you can write the code that looks like a static method being overridden, but it won't behave like an overridden method.\"))), mdx(\"p\", null, \"*Notice that \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/Accessing-Static-members-using-objects\",\n    \"title\": \"Accessing Static members using objects\"\n  }, \"[[Accessing Static members using objects]]\"), \" is possible\"));\n}\n;\nMDXContent.isMDXComponent = true;","outboundReferences":[{"__typename":"Mdx","body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"runtime-polymorphism-or-dynamic-method-dispatch\"\n  }, \"Runtime Polymorphism or Dynamic Method Dispatch\"), mdx(\"h2\", {\n    \"id\": \"method-overriding--dynamic-binding--runtime-polymorphism\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"/Method-Overriding\",\n    \"title\": \"Method Overriding\"\n  }, \"[[Method Overriding]]\"), \" + \", mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"/Dynamic-Binding\",\n    \"title\": \"Dynamic Binding\"\n  }, \"[[Dynamic Binding]]\"), \" = Runtime Polymorphism\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Method Overriding - Which Method to call depends on object type\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"++\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Dynamic Binding - Object type determined at runtime\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"=> Which method to call - decided at runtime\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"-> Runtime Polymorphism\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/Object-being-referred-to-determines-the-version-of-method-to-be-called\",\n    \"title\": \"Object being referred to determines the version of method to be called\"\n  }, \"[[Object being referred to determines the version of method to be called]]\"), \"\")), mdx(\"h2\", {\n    \"id\": \"references\"\n  }, \"References\"), mdx(\"p\", null, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://www.geeksforgeeks.org/dynamic-method-dispatch-runtime-polymorphism-java/\"\n  }, \"GFG - Dynamic Method Dispatch or Runtime Polymmorphism in Java\")));\n}\n;\nMDXContent.isMDXComponent = true;","frontmatter":{"aliases":[]},"parent":{"__typename":"File","id":"3ee24743-22de-5191-bc08-a2dda5ad44ce","fields":{"slug":"/Runtime Polymorphism or Dynamic Method Dispatch","title":"Runtime Polymorphism or Dynamic Method Dispatch"}}},{"__typename":"Mdx","body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"accessing-static-members-using-objects\"\n  }, \"Accessing \", mdx(\"a\", {\n    parentName: \"h1\",\n    \"href\": \"/Static\",\n    \"title\": \"Static\"\n  }, \"[[Static]]\"), \" members using objects\"), mdx(\"p\", null, \"Its possible to write f.classMethod(). It is legal but a bad idea, since it causes confusion. The instance is not important in case of class methods. Only the declared type of 'f' matters.\"), mdx(\"p\", null, \"Its better to write Foo.classMethod() or Bar.classMethod(). This not only makes it clear which class method you would like to call. But also, that it is indeed a class method which you're calling.\"), mdx(\"p\", null, \"Of course, all this could be avoided by simply trying to not overide your static methods. You know, because \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/Static-Methods-can't-be-overridden\",\n    \"title\": \"Static Methods can't be overridden\"\n  }, \"[[Static Methods can't be overridden]]\"), \"\"));\n}\n;\nMDXContent.isMDXComponent = true;","frontmatter":{"aliases":[]},"parent":{"__typename":"File","id":"e866bee3-734c-5e25-8ef0-bb071693d7fe","fields":{"slug":"/Accessing Static members using objects","title":"Accessing [[Static]] members using objects"}}}],"inboundReferences":[{"__typename":"Mdx","body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"shadowing-or-hiding\"\n  }, \"Shadowing or Hiding\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Overriding\"), \" => In case of non-static methods\"), mdx(\"pre\", {\n    parentName: \"li\"\n  }, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-java\"\n  }, \"class A{\\n    public void show(){\\n    System.out.println(\\\"in A\\\");\\n    }\\n}\\n\\nclass B extends A{\\n    public void show(){\\n    System.out.println(\\\"in B\\\");\\n    }\\n}\\n\"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Hiding\"), \" => In case of all other members (instance members, static members, static methods)\"), mdx(\"pre\", {\n    parentName: \"li\"\n  }, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-java\"\n  }, \"class A{\\nint a;\\nstatic int b;\\nstatic meth();\\n}\\n\\nclass B extends A{\\nint a;\\nstatic int b;\\nstatic meth();\\n}\\n\\n//class B now has both properties.\\n//'a' from its own class\\n\")))), mdx(\"h2\", {\n    \"id\": \"major-difference-between-method-overriding-and-hiding\"\n  }, \"Major Difference between \", mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"/Method-Overriding\",\n    \"title\": \"Method Overriding\"\n  }, \"[[Method Overriding]]\"), \" and Hiding\"), mdx(\"p\", null, \"This\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-java\"\n  }, \"class Foo {\\n    public void method() {\\n        System.out.println(\\\"in Foo\\\");\\n    }\\n}\\n \\nclass Bar extends Foo {\\n    public void method() {\\n        System.out.println(\\\"in Bar\\\");\\n    }\\n}\\n\")), mdx(\"p\", null, \"is not the same as this\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-java\"\n  }, \"class Foo {\\n    public static void method() {\\n        System.out.println(\\\"in Foo\\\");\\n    }\\n}\\n \\nclass Bar extends Foo {\\n    public static void method() {\\n        System.out.println(\\\"in Bar\\\");\\n    }\\n}\\n\")), mdx(\"p\", null, \"Both the codes compile and run fine.\"), mdx(\"p\", null, \"But the second one isn't an example of one static method overriding another static method. Its an example of a static method hiding another static method.\"), mdx(\"p\", null, \"What's the difference?\"), mdx(\"p\", null, \"=> \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/Runtime-Polymorphism-When-you-override-you-get-it-when-you-hide-you-don't\",\n    \"title\": \"Runtime Polymorphism -- When you override - you get it -- when you hide - you don't\"\n  }, \"[[Runtime Polymorphism -- When you override - you get it -- when you hide - you don't]]\"), \"\"), mdx(\"p\", null, \"[\", \"[Why compiler sometimes talks about overriding static methods]\"));\n}\n;\nMDXContent.isMDXComponent = true;","parent":{"__typename":"File","id":"a8fe3a53-06b5-578e-bec8-c3bc35a7a2e2","fields":{"slug":"/Shadowing or Hiding","title":"Shadowing or Hiding"}}}]},"fields":{"slug":"/Runtime Polymorphism -- When you override - you get it -- when you hide - you don't","title":"[[Runtime Polymorphism or Dynamic Method Dispatch]] -- When you override - you get it -- when you hide - you don't"}}},"pageContext":{"id":"a38389e7-ffbe-546e-9b73-844f4aeda1b1"}},"staticQueryHashes":["2098632890","2221750479","2468095761"]}