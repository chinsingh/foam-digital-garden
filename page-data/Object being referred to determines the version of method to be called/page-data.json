{"componentChunkName":"component---node-modules-gatsby-theme-garden-src-templates-local-file-js","path":"/Object being referred to determines the version of method to be called","result":{"data":{"file":{"childMdx":{"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"object-being-referred-to-determines-the-version-of-method-to-be-called\"\n  }, \"Object being referred to determines the version of method to be called\"), mdx(\"p\", null, \"The object being referred to (not the reference variable) determines the version of method to be called.\"), mdx(\"p\", null, \"So in this example, if Student has a method overriding a method in Human. Student's method will be called because even though h is an object of Human, it is referring to an object of Student.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-java\"\n  }, \"Human h = new Student();\\nh.overriddenMethod();\\n\")), mdx(\"h2\", {\n    \"id\": \"references\"\n  }, \"References\"), mdx(\"p\", null, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://www.geeksforgeeks.org/dynamic-method-dispatch-runtime-polymorphism-java/\"\n  }, \"GFG - Dynamic Method Dispatch or Runtime Polymmorphism in Java\")));\n}\n;\nMDXContent.isMDXComponent = true;","outboundReferences":[],"inboundReferences":[{"__typename":"Mdx","body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"runtime-polymorphism-or-dynamic-method-dispatch\"\n  }, \"Runtime Polymorphism or Dynamic Method Dispatch\"), mdx(\"h2\", {\n    \"id\": \"method-overriding--dynamic-binding--runtime-polymorphism\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"/Method-Overriding\",\n    \"title\": \"Method Overriding\"\n  }, \"[[Method Overriding]]\"), \" + \", mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"/Dynamic-Binding\",\n    \"title\": \"Dynamic Binding\"\n  }, \"[[Dynamic Binding]]\"), \" = Runtime Polymorphism\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Method Overriding - Which Method to call depends on object type\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"++\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Dynamic Binding - Object type determined at runtime\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"=> Which method to call - decided at runtime\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"-> Runtime Polymorphism\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/Object-being-referred-to-determines-the-version-of-method-to-be-called\",\n    \"title\": \"Object being referred to determines the version of method to be called\"\n  }, \"[[Object being referred to determines the version of method to be called]]\"), \"\")), mdx(\"h2\", {\n    \"id\": \"references\"\n  }, \"References\"), mdx(\"p\", null, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://www.geeksforgeeks.org/dynamic-method-dispatch-runtime-polymorphism-java/\"\n  }, \"GFG - Dynamic Method Dispatch or Runtime Polymmorphism in Java\")));\n}\n;\nMDXContent.isMDXComponent = true;","parent":{"__typename":"File","id":"3ee24743-22de-5191-bc08-a2dda5ad44ce","fields":{"slug":"/Runtime Polymorphism or Dynamic Method Dispatch","title":"Runtime Polymorphism or Dynamic Method Dispatch"}}}]},"fields":{"slug":"/Object being referred to determines the version of method to be called","title":"Object being referred to determines the version of method to be called"}}},"pageContext":{"id":"d39a01a7-bf48-5125-8dd0-3e034595aa02"}},"staticQueryHashes":["2098632890","2221750479","2468095761"]}