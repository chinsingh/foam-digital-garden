{"componentChunkName":"component---node-modules-gatsby-theme-garden-src-templates-local-file-js","path":"/Composition over Inheritance","result":{"data":{"file":{"childMdx":{"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"composition-over-inheritance\"\n  }, \"[\", mdx(\"a\", {\n    parentName: \"h1\",\n    \"href\": \"/notes/9215efa6640b7132f49e0e4cfa7c194d/Composition.md\",\n    \"title\": \"Composition\"\n  }, \"Composition\"), \"] over [\", mdx(\"a\", {\n    parentName: \"h1\",\n    \"href\": \"/notes/dc273c3092363fcefa7e110ae5047531/Inheritance.md\",\n    \"title\": \"Inheritance\"\n  }, \"Inheritance\"), \"]\"), mdx(\"p\", null, \"aka \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Composite reuse Principle\"), \".\"), mdx(\"p\", null, \"It is a OOP principle which encourages the usage of composition for code reuse instead of inheritance.\"), mdx(\"p\", null, \"However, it is still a principle and [\", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/notes/bcce5e42d470c041f5d65a28fd681a25/a%20principle%20is%20just%20in%20principle.md\",\n    \"title\": \"a principle is just in principle\"\n  }, \"a principle is just in principle\"), \"]. Hence, this can be reframed better as -\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"If you are going to use inheritance - think again, chances are you need composition.\")), mdx(\"h2\", {\n    \"id\": \"trade-offs\"\n  }, \"Trade-offs\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/Purpose-of-Inheritance\",\n    \"title\": \"Purpose of Inheritance\"\n  }, \"[[Purpose of Inheritance]]\"), \" vs \", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/Disadvantages-of-Inheritance\",\n    \"title\": \"Disadvantages of Inheritance\"\n  }, \"[[Disadvantages of Inheritance]]\"), \"\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/Benefits-of-Composition\",\n    \"title\": \"Benefits of Composition\"\n  }, \"[[Benefits of Composition]]\"), \" vs \", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/Disadvantage-of-Composition\",\n    \"title\": \"Disadvantage of Composition\"\n  }, \"[[Disadvantage of Composition]]\"), \"\")), mdx(\"h2\", {\n    \"id\": \"references\"\n  }, \"References\"), mdx(\"p\", null, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://stackoverflow.com/questions/49002/prefer-composition-over-inheritance\"\n  }, \"Prefer composition over inheritance? - Stack Overflow\")));\n}\n;\nMDXContent.isMDXComponent = true;","outboundReferences":[{"__typename":"Mdx","body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"composition\"\n  }, \"Composition\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Special Case of Aggregation.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"When one class is highly dependent on the other. For example, Library and books.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Strong Existence Relation \\u2014 Composition means that the contained object cannot exist without the aggregation (for example, a car reservation cannot exist without the car rental agency).\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Lifetime of individual parts = Lifetime of aggregate\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"What kind of relationship?\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"PART - OF\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Existence-dependent whole-part relationship\")))));\n}\n;\nMDXContent.isMDXComponent = true;","frontmatter":{"aliases":[]},"parent":{"__typename":"File","id":"f813b4df-8966-5bfc-beef-deb843f9d3d5","fields":{"slug":"/Composition","title":"Composition"}}},{"__typename":"Mdx","body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"inheritance\"\n  }, \"Inheritance\"), mdx(\"p\", null, \"Mechanism through which an object acquires all the properties and methods of its parent\"), mdx(\"h2\", {\n    \"id\": \"implemented-by\"\n  }, \"Implemented by\"), mdx(\"p\", null, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"extends\"), \" keyword\"), mdx(\"h2\", {\n    \"id\": \"what-kind-of-relationship\"\n  }, \"What kind of relationship?\"), mdx(\"p\", null, \"IS - A\"), mdx(\"h2\", {\n    \"id\": \"what-is-inherited\"\n  }, \"What is inherited?\"), mdx(\"p\", null, \"\\uD83D\\uDCA1 By inherited, it is meant that these fields and methods are part of of the subclass, as if the subclass had declared them itself.\"), mdx(\"p\", null, \"When a subclass inherits a superclass, all protected and public fields and methods of the superclass are inherited by the subclass.  Protected and public fields can be called and referenced just like the methods declared directly in the subclass.\"), mdx(\"p\", null, \"Private fields and methods of the superclass can never be referenced directly by subclasses. They can, however, be referenced indirectly via methods reachable from the subclass (e.g default (package), protected and public methods).\"), mdx(\"h2\", {\n    \"id\": \"types-of-inheritance\"\n  }, \"Types of Inheritance\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/Single-Inheritance\",\n    \"title\": \"Single Inheritance\"\n  }, \"[[Single Inheritance]]\"), \"\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/Multilevel-Inheritance\",\n    \"title\": \"Multilevel Inheritance\"\n  }, \"[[Multilevel Inheritance]]\"), \"\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/Multiple-Inheritance\",\n    \"title\": \"Multiple Inheritance\"\n  }, \"[[Multiple Inheritance]]\"), \"\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/Hierarchical-Inheritance\",\n    \"title\": \"Hierarchical Inheritance\"\n  }, \"[[Hierarchical Inheritance]]\"), \"\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/Hybrid-Inheritance\",\n    \"title\": \"Hybrid Inheritance\"\n  }, \"[[Hybrid Inheritance]]\"), \"\")));\n}\n;\nMDXContent.isMDXComponent = true;","frontmatter":{"aliases":[]},"parent":{"__typename":"File","id":"85692676-9abf-55da-ac13-094c7fdf61fb","fields":{"slug":"/Inheritance","title":"Inheritance"}}},{"__typename":"Mdx","body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"a-principle-is-just-in-principle\"\n  }, \"a principle is just in principle\"), mdx(\"p\", null, \"A principle is just that - a principle. It can nudge you towards the correct direction. But it may or may not apply to your situation. Only you have the actual and close understanding of your situation and what's going on.\"));\n}\n;\nMDXContent.isMDXComponent = true;","frontmatter":{"aliases":[]},"parent":{"__typename":"File","id":"46ce757f-b997-5d9e-b39b-ef9c37f58b8c","fields":{"slug":"/a principle is just in principle","title":"a principle is just in principle"}}},{"__typename":"Mdx","body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"purpose-of-inheritance\"\n  }, \"Purpose of [\", mdx(\"a\", {\n    parentName: \"h1\",\n    \"href\": \"notes/Inheritance.md\",\n    \"title\": \"Inheritance\"\n  }, \"Inheritance\"), \"]\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"[\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"notes/Subtyping.md\",\n    \"title\": \"Subtyping\"\n  }, \"Subtyping\"), \"]: Also see \", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/Liskov-Substitution-Principle\",\n    \"title\": \"Liskov Substitution Principle\"\n  }, \"[[Liskov Substitution Principle]]\"), \"\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Straightforward \", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/open-recursion\",\n    \"title\": \"open recursion\"\n  }, \"[[open recursion]]\"), \"\"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"[\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"notes/Subclassing.md\",\n    \"title\": \"Subclassing\"\n  }, \"Subclassing\"), \"]: Straightforward Code reuse\")), mdx(\"h2\", {\n    \"id\": \"references\"\n  }, \"References\"), mdx(\"p\", null, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://stackoverflow.com/questions/49002/prefer-composition-over-inheritance\"\n  }, \"Prefer composition over inheritance? - Stack Overflow\")));\n}\n;\nMDXContent.isMDXComponent = true;","frontmatter":{"aliases":[]},"parent":{"__typename":"File","id":"808d108f-bf34-58ed-85f5-1f1ec0b5dbd1","fields":{"slug":"/Purpose of Inheritance","title":"Purpose of [[Inheritance]]"}}},{"__typename":"Mdx","body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"disadvantages-of-inheritance\"\n  }, \"Disadvantages of Inheritance\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"You can't change the implementation provided by superclass at runtime. Inheritance is defined at compile time.\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Inheritance is said to \\\"break encapsulation\\\" by exposing a subclass to protected members of parent class\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Leads to child class being tightly coupled with parent class. Changes in parent class will lead to changes in subclass.\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Excessive deep inheritance trees can make inheritance stack very deep and confusing.\")), mdx(\"h2\", {\n    \"id\": \"references\"\n  }, \"References\"), mdx(\"p\", null, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://stackoverflow.com/questions/49002/prefer-composition-over-inheritance\"\n  }, \"Prefer composition over inheritance? - Stack Overflow\")));\n}\n;\nMDXContent.isMDXComponent = true;","frontmatter":{"aliases":[]},"parent":{"__typename":"File","id":"7392218a-577d-5445-b9e0-2b0d6cbe4fbb","fields":{"slug":"/Disadvantages of Inheritance","title":"Disadvantages of Inheritance"}}},{"__typename":"Mdx","body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"benefits-of-composition\"\n  }, \"Benefits of [\", mdx(\"a\", {\n    parentName: \"h1\",\n    \"href\": \"/notes/9215efa6640b7132f49e0e4cfa7c194d/Composition.md\",\n    \"title\": \"Composition\"\n  }, \"Composition\"), \"]\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/Inversion-of-Control-(IoC)\",\n    \"title\": \"Inversion of Control (IoC)\"\n  }, \"[[Inversion of Control (IoC)]]\"), \": It can take benefit of \", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/Dependency-Injection\",\n    \"title\": \"Dependency Injection\"\n  }, \"[[Dependency Injection]]\"), \". For example, in \", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/Decorator-Pattern\",\n    \"title\": \"Decorator Pattern\"\n  }, \"[[Decorator Pattern]]\"), \" and \", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/Proxy-Pattern\",\n    \"title\": \"Proxy Pattern\"\n  }, \"[[Proxy Pattern]]\"), \".\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/Combinator\",\n    \"title\": \"Combinator\"\n  }, \"[[Combinator]]\"), \"-oriented programming: Similar to \", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/Composite-pattern\",\n    \"title\": \"Composite pattern\"\n  }, \"[[Composite pattern]]\"), \"\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Readily follows \", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/Programming-to-an-interface\",\n    \"title\": \"Programming to an interface\"\n  }, \"[[Programming to an interface]]\"), \"\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Easy \", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/Multiple-Inheritance\",\n    \"title\": \"Multiple Inheritance\"\n  }, \"[[Multiple Inheritance]]\"), \"\")), mdx(\"h2\", {\n    \"id\": \"references\"\n  }, \"References\"), mdx(\"p\", null, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://stackoverflow.com/questions/49002/prefer-composition-over-inheritance\"\n  }, \"Prefer composition over inheritance? - Stack Overflow\")));\n}\n;\nMDXContent.isMDXComponent = true;","frontmatter":{"aliases":[]},"parent":{"__typename":"File","id":"fcf96474-4932-5905-be80-43b57c16327d","fields":{"slug":"/Benefits of Composition","title":"Benefits of [[Composition]]"}}},{"__typename":"Mdx","body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"disadvantage-of-composition\"\n  }, \"Disadvantage of Composition\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Can be verbose: Can sometimes create conflict with the \", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/DRY\",\n    \"title\": \"DRY\"\n  }, \"[[DRY]]\"), \" principle, but it's generally not that bad, at least compared to the myriad of pitfalls associated with inheritance.\")), mdx(\"h2\", {\n    \"id\": \"references\"\n  }, \"References\"), mdx(\"p\", null, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://stackoverflow.com/questions/49002/prefer-composition-over-inheritance\"\n  }, \"Prefer composition over inheritance? - Stack Overflow\")));\n}\n;\nMDXContent.isMDXComponent = true;","frontmatter":{"aliases":[]},"parent":{"__typename":"File","id":"b93f6a5f-8289-5093-84c6-fc2c7a400f31","fields":{"slug":"/Disadvantage of Composition","title":"Disadvantage of Composition"}}}],"inboundReferences":[{"__typename":"Mdx","body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"strategy-pattern\"\n  }, \"Strategy Pattern\"), mdx(\"p\", null, \"It is a \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/Behavioural-Design-Pattern\",\n    \"title\": \"Behavioural Design Pattern\"\n  }, \"[[Behavioural Design Pattern]]\"), \".\"), mdx(\"h2\", {\n    \"id\": \"goal\"\n  }, \"Goal\"), mdx(\"p\", null, \"Giving different variation of certain behavioural capability to a \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/same-same-but-different-classes\",\n    \"title\": \"same-same-but-different classes\"\n  }, \"[[same-same-but-different classes]]\"), \" where the classes are related close-enough so as to be inheriting from a single class.\"), mdx(\"h2\", {\n    \"id\": \"solution\"\n  }, \"Solution\"), mdx(\"p\", null, \"The first straightforward solution which comes to mind is to create a method in the parent class and redefine the specific behavior in child classes by \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/method-overriding\",\n    \"title\": \"method overriding\"\n  }, \"[[method overriding]]\"), \".\"), mdx(\"p\", null, \"However, this would lead to \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/dependency\",\n    \"title\": \"dependency\"\n  }, \"[[dependency]]\"), \" of the child classes on the parent class. Also, there are many \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/Disadvantages-of-Inheritance\",\n    \"title\": \"Disadvantages of Inheritance\"\n  }, \"[[Disadvantages of Inheritance]]\"), \" too.\\nIn many cases, its wise to choose or at least consider using \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/Composition-over-Inheritance\",\n    \"title\": \"Composition over Inheritance\"\n  }, \"[[Composition over Inheritance]]\"), \".\"), mdx(\"p\", null, \"Strategy Pattern provides an elegant solution to this.\"), mdx(\"h2\", {\n    \"id\": \"elaboration\"\n  }, \"Elaboration\"), mdx(\"p\", null, \"We'll call the parent class 'Context' and the subclasses 'clients'.\"), mdx(\"h3\", {\n    \"id\": \"strategy-interface-and-concrete-strategies\"\n  }, \"Strategy interface and Concrete strategies\"), mdx(\"p\", null, \"Strategy Pattern uses an 'Strategy' interface which is common interface to different 'concrete strategy' classes which implement different variants of a certain behavior (which we want to give to the client classes).\"), mdx(\"h3\", {\n    \"id\": \"context\"\n  }, \"Context\"), mdx(\"p\", null, \"The Context contains an object of the Strategy interface - so this object can be polymorphically changed to behave as any of the concrete strategies.\"), mdx(\"p\", null, \"Context also has a setter to set the concrete strategy at runtime.\"), mdx(\"h3\", {\n    \"id\": \"client\"\n  }, \"Client\"), mdx(\"p\", null, \"The client can thus change the behavior as many times at it wants through the setter and when the method to execute the said behavior is called - it will result in whatever behavior the client wanted to have.\"), mdx(\"p\", null, mdx(\"img\", {\n    parentName: \"p\",\n    \"src\": \"../attachments/2023-02-11-15-52-10-strategy-pattern.png\",\n    \"alt\": \"Strategy pattern\"\n  })), mdx(\"h2\", {\n    \"id\": \"example\"\n  }, \"Example\"), mdx(\"p\", null, \"Consider three classes, Animal, Dog and Bird. Animal is the parent class for both Dog and Bird and we want to give flying behavior to these subclasses.\"), mdx(\"p\", null, \"So again, we could inherit a common \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"fly()\"), \" method and override it in Dog but that's not good code. We could also implement a fly method everytime we want a class, like bird, to have a flying capability. But that voilates the \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/DRY\",\n    \"title\": \"DRY\"\n  }, \"[[DRY]]\"), \" principle.\"), mdx(\"p\", null, \"Instead, we create another interface, say \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Flys\"), \" which has a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"fly()\"), \" method. This method can be implemented by different concrete classes - in this case - \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ItFlys\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"CantFly\"), \". Now, we add an object of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Flys\"), \" type to the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Animal\"), \" class. This object can be set by its subclasses through a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"setFlyingAbility()\"), \" method. The \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Animal\"), \" class will also have a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"tryToFly()\"), \" method which will call the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"fly()\"), \" method of the strategy object.\"), mdx(\"p\", null, \"In this case, we set the flying ability for \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Dog\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Bird\"), \" in their respective constructors. For \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Dog\"), \", we pass an object of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"CantFly\"), \" type to the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"setFlyingAbility()\"), \" method and for \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Bird\"), \", we pass an object of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ItFlys\"), \" type.\"), mdx(\"p\", null, \"Now, whenever the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"tryToFly()\"), \" method is called from an object of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Dog\"), \" or \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Bird\"), \", it will behave in the intended manner as specified in the constructors of those classes.\"), mdx(\"h2\", {\n    \"id\": \"references\"\n  }, \"References\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Easy to understand example - \", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://www.youtube.com/watch?v=-NCgRD9-C6o&ab_channel=DerekBanas\"\n  }, \"Strategy Design Pattern - Derek Banas\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://refactoring.guru/design-patterns/strategy\"\n  }, \"Strategy\"))));\n}\n;\nMDXContent.isMDXComponent = true;","parent":{"__typename":"File","id":"9c1d69f1-0fbb-543f-b5f9-2d9ee7258681","fields":{"slug":"/Strategy Pattern","title":"Strategy Pattern"}}}]},"fields":{"slug":"/Composition over Inheritance","title":"[[Composition]] over [[Inheritance]]"}}},"pageContext":{"id":"8cdd0bb0-9895-5a32-a23c-f27cdbe10c36"}},"staticQueryHashes":["2098632890","2221750479","2468095761"]}