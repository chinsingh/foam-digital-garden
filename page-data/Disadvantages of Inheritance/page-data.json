{"componentChunkName":"component---node-modules-gatsby-theme-garden-src-templates-local-file-js","path":"/Disadvantages of Inheritance","result":{"data":{"file":{"childMdx":{"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"disadvantages-of-inheritance\"\n  }, \"Disadvantages of Inheritance\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"You can't change the implementation provided by superclass at runtime. Inheritance is defined at compile time.\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Inheritance is said to \\\"break encapsulation\\\" by exposing a subclass to protected members of parent class\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Leads to child class being tightly coupled with parent class. Changes in parent class will lead to changes in subclass.\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Excessive deep inheritance trees can make inheritance stack very deep and confusing.\")), mdx(\"h2\", {\n    \"id\": \"references\"\n  }, \"References\"), mdx(\"p\", null, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://stackoverflow.com/questions/49002/prefer-composition-over-inheritance\"\n  }, \"Prefer composition over inheritance? - Stack Overflow\")));\n}\n;\nMDXContent.isMDXComponent = true;","outboundReferences":[],"inboundReferences":[{"__typename":"Mdx","body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"composition-over-inheritance\"\n  }, \"[\", mdx(\"a\", {\n    parentName: \"h1\",\n    \"href\": \"/notes/9215efa6640b7132f49e0e4cfa7c194d/Composition.md\",\n    \"title\": \"Composition\"\n  }, \"Composition\"), \"] over [\", mdx(\"a\", {\n    parentName: \"h1\",\n    \"href\": \"/notes/dc273c3092363fcefa7e110ae5047531/Inheritance.md\",\n    \"title\": \"Inheritance\"\n  }, \"Inheritance\"), \"]\"), mdx(\"p\", null, \"aka \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Composite reuse Principle\"), \".\"), mdx(\"p\", null, \"It is a OOP principle which encourages the usage of composition for code reuse instead of inheritance.\"), mdx(\"p\", null, \"However, it is still a principle and [\", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/notes/bcce5e42d470c041f5d65a28fd681a25/a%20principle%20is%20just%20in%20principle.md\",\n    \"title\": \"a principle is just in principle\"\n  }, \"a principle is just in principle\"), \"]. Hence, this can be reframed better as -\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"If you are going to use inheritance - think again, chances are you need composition.\")), mdx(\"h2\", {\n    \"id\": \"trade-offs\"\n  }, \"Trade-offs\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/Purpose-of-Inheritance\",\n    \"title\": \"Purpose of Inheritance\"\n  }, \"[[Purpose of Inheritance]]\"), \" vs \", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/Disadvantages-of-Inheritance\",\n    \"title\": \"Disadvantages of Inheritance\"\n  }, \"[[Disadvantages of Inheritance]]\"), \"\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/Benefits-of-Composition\",\n    \"title\": \"Benefits of Composition\"\n  }, \"[[Benefits of Composition]]\"), \" vs \", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/Disadvantage-of-Composition\",\n    \"title\": \"Disadvantage of Composition\"\n  }, \"[[Disadvantage of Composition]]\"), \"\")), mdx(\"h2\", {\n    \"id\": \"references\"\n  }, \"References\"), mdx(\"p\", null, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://stackoverflow.com/questions/49002/prefer-composition-over-inheritance\"\n  }, \"Prefer composition over inheritance? - Stack Overflow\")));\n}\n;\nMDXContent.isMDXComponent = true;","parent":{"__typename":"File","id":"8cdd0bb0-9895-5a32-a23c-f27cdbe10c36","fields":{"slug":"/Composition over Inheritance","title":"[[Composition]] over [[Inheritance]]"}}},{"__typename":"Mdx","body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"strategy-pattern\"\n  }, \"Strategy Pattern\"), mdx(\"p\", null, \"It is a \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/Behavioural-Design-Pattern\",\n    \"title\": \"Behavioural Design Pattern\"\n  }, \"[[Behavioural Design Pattern]]\"), \".\"), mdx(\"h2\", {\n    \"id\": \"goal\"\n  }, \"Goal\"), mdx(\"p\", null, \"Giving different variation of certain behavioural capability to a \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/same-same-but-different-classes\",\n    \"title\": \"same-same-but-different classes\"\n  }, \"[[same-same-but-different classes]]\"), \" where the classes are related close-enough so as to be inheriting from a single class.\"), mdx(\"h2\", {\n    \"id\": \"solution\"\n  }, \"Solution\"), mdx(\"p\", null, \"The first straightforward solution which comes to mind is to create a method in the parent class and redefine the specific behavior in child classes by \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/method-overriding\",\n    \"title\": \"method overriding\"\n  }, \"[[method overriding]]\"), \".\"), mdx(\"p\", null, \"However, this would lead to \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/dependency\",\n    \"title\": \"dependency\"\n  }, \"[[dependency]]\"), \" of the child classes on the parent class. Also, there are many \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/Disadvantages-of-Inheritance\",\n    \"title\": \"Disadvantages of Inheritance\"\n  }, \"[[Disadvantages of Inheritance]]\"), \" too.\\nIn many cases, its wise to choose or at least consider using \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/Composition-over-Inheritance\",\n    \"title\": \"Composition over Inheritance\"\n  }, \"[[Composition over Inheritance]]\"), \".\"), mdx(\"p\", null, \"Strategy Pattern provides an elegant solution to this.\"), mdx(\"h2\", {\n    \"id\": \"elaboration\"\n  }, \"Elaboration\"), mdx(\"p\", null, \"We'll call the parent class 'Context' and the subclasses 'clients'.\"), mdx(\"h3\", {\n    \"id\": \"strategy-interface-and-concrete-strategies\"\n  }, \"Strategy interface and Concrete strategies\"), mdx(\"p\", null, \"Strategy Pattern uses an 'Strategy' interface which is common interface to different 'concrete strategy' classes which implement different variants of a certain behavior (which we want to give to the client classes).\"), mdx(\"h3\", {\n    \"id\": \"context\"\n  }, \"Context\"), mdx(\"p\", null, \"The Context contains an object of the Strategy interface - so this object can be polymorphically changed to behave as any of the concrete strategies.\"), mdx(\"p\", null, \"Context also has a setter to set the concrete strategy at runtime.\"), mdx(\"h3\", {\n    \"id\": \"client\"\n  }, \"Client\"), mdx(\"p\", null, \"The client can thus change the behavior as many times at it wants through the setter and when the method to execute the said behavior is called - it will result in whatever behavior the client wanted to have.\"), mdx(\"p\", null, mdx(\"img\", {\n    parentName: \"p\",\n    \"src\": \"../attachments/2023-02-11-15-52-10-strategy-pattern.png\",\n    \"alt\": \"Strategy pattern\"\n  })), mdx(\"h2\", {\n    \"id\": \"example\"\n  }, \"Example\"), mdx(\"p\", null, \"Consider three classes, Animal, Dog and Bird. Animal is the parent class for both Dog and Bird and we want to give flying behavior to these subclasses.\"), mdx(\"p\", null, \"So again, we could inherit a common \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"fly()\"), \" method and override it in Dog but that's not good code. We could also implement a fly method everytime we want a class, like bird, to have a flying capability. But that voilates the \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/DRY\",\n    \"title\": \"DRY\"\n  }, \"[[DRY]]\"), \" principle.\"), mdx(\"p\", null, \"Instead, we create another interface, say \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Flys\"), \" which has a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"fly()\"), \" method. This method can be implemented by different concrete classes - in this case - \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ItFlys\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"CantFly\"), \". Now, we add an object of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Flys\"), \" type to the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Animal\"), \" class. This object can be set by its subclasses through a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"setFlyingAbility()\"), \" method. The \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Animal\"), \" class will also have a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"tryToFly()\"), \" method which will call the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"fly()\"), \" method of the strategy object.\"), mdx(\"p\", null, \"In this case, we set the flying ability for \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Dog\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Bird\"), \" in their respective constructors. For \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Dog\"), \", we pass an object of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"CantFly\"), \" type to the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"setFlyingAbility()\"), \" method and for \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Bird\"), \", we pass an object of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ItFlys\"), \" type.\"), mdx(\"p\", null, \"Now, whenever the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"tryToFly()\"), \" method is called from an object of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Dog\"), \" or \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Bird\"), \", it will behave in the intended manner as specified in the constructors of those classes.\"), mdx(\"h2\", {\n    \"id\": \"references\"\n  }, \"References\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Easy to understand example - \", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://www.youtube.com/watch?v=-NCgRD9-C6o&ab_channel=DerekBanas\"\n  }, \"Strategy Design Pattern - Derek Banas\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://refactoring.guru/design-patterns/strategy\"\n  }, \"Strategy\"))));\n}\n;\nMDXContent.isMDXComponent = true;","parent":{"__typename":"File","id":"9c1d69f1-0fbb-543f-b5f9-2d9ee7258681","fields":{"slug":"/Strategy Pattern","title":"Strategy Pattern"}}}]},"fields":{"slug":"/Disadvantages of Inheritance","title":"Disadvantages of Inheritance"}}},"pageContext":{"id":"7392218a-577d-5445-b9e0-2b0d6cbe4fbb"}},"staticQueryHashes":["2098632890","2221750479","2468095761"]}