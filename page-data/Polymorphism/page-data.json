{"componentChunkName":"component---node-modules-gatsby-theme-garden-src-templates-local-file-js","path":"/Polymorphism","result":{"data":{"file":{"childMdx":{"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"polymorphism\"\n  }, \"Polymorphism\"), mdx(\"h2\", {\n    \"id\": \"what-is-it\"\n  }, \"What is it?\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Many forms\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Methods with same name can be used for different purposes\")), mdx(\"h2\", {\n    \"id\": \"implemented-by\"\n  }, \"Implemented By\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/Method-Overloading\",\n    \"title\": \"Method Overloading\"\n  }, \"[[Method Overloading]]\"), \"\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/Method-Overriding\",\n    \"title\": \"Method Overriding\"\n  }, \"[[Method Overriding]]\"), \"\")), mdx(\"h2\", {\n    \"id\": \"why-polymorphism\"\n  }, \"Why Polymorphism?\"));\n}\n;\nMDXContent.isMDXComponent = true;","outboundReferences":[{"__typename":"Mdx","body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"method-overloading\"\n  }, \"Method Overloading\"), mdx(\"p\", null, \"When multiple methods have same signature and are called according to the arguments passed.\"), mdx(\"h2\", {\n    \"id\": \"how-can-it-be-achieved\"\n  }, \"How can it be achieved?\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Using different data types of parameters\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Using variable count of parameters\")));\n}\n;\nMDXContent.isMDXComponent = true;","frontmatter":{"aliases":[]},"parent":{"__typename":"File","id":"f3aa281f-83fb-5dab-820e-a8e01d0a8998","fields":{"slug":"/Method Overloading","title":"Method Overloading"}}},{"__typename":"Mdx","body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"method-overriding\"\n  }, \"Method Overriding\"), mdx(\"p\", null, \"When a child class has same method as that of a parent class, that method is said to override the parent's method.\"), mdx(\"h2\", {\n    \"id\": \"how-can-it-be-achieved\"\n  }, \"How can it be achieved?\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Method must have same name as parent\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Same parameter as parent\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Return type must be same or have an IS-A relationship with parent method's return type \", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/Covariant-Return-Types\",\n    \"title\": \"Covariant Return Types\"\n  }, \"[[Covariant Return Types]]\"), \".\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Overridden method should not be more restrictive than parent method.\")));\n}\n;\nMDXContent.isMDXComponent = true;","frontmatter":{"aliases":[]},"parent":{"__typename":"File","id":"546d3fe8-8725-51c7-9b8e-54717c1046ee","fields":{"slug":"/Method Overriding","title":"Method Overriding"}}}],"inboundReferences":[{"__typename":"Mdx","body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"upcasting\"\n  }, \"Upcasting\"), mdx(\"p\", null, \"Casting from subclass to superclass\"), mdx(\"h2\", {\n    \"id\": \"syntax\"\n  }, \"Syntax\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Generally, \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/Implicit-Casting\",\n    \"title\": \"Implicit Casting\"\n  }, \"[[Implicit Casting]]\"), \". Why?\"), mdx(\"p\", {\n    parentName: \"li\"\n  }, \"=> Compiler knows that \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Cat\"), \" is an \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Animal.\"), \" \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/Liskov-Substitution-Principle\",\n    \"title\": \"Liskov Substitution Principle\"\n  }, \"[[Liskov Substitution Principle]]\"), \"\"))), mdx(\"h2\", {\n    \"id\": \"what-upcasting-gives-us\"\n  }, \"What upcasting gives us?\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/Polymorphism\",\n    \"title\": \"Polymorphism\"\n  }, \"[[Polymorphism]]\"), \"\"), mdx(\"p\", {\n    parentName: \"li\"\n  }, \"  Instead of using different methods for a common functionality in each of the sub classes, we can have a common method in the superclass for that functionality and all subclass objects will be casted implicitly.\"), mdx(\"p\", {\n    parentName: \"li\"\n  }, \"  Example - a feed(Animal animal) function to which we can pass objects of Cat and Dog classes \\u2192 feed(cat); feed(dog);\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/Method-Overriding\",\n    \"title\": \"Method Overriding\"\n  }, \"[[Method Overriding]]\"), \"\"), mdx(\"p\", {\n    parentName: \"li\"\n  }, \"  When an object is upcasted, it still can call overridden methods from its original class.\"), mdx(\"p\", {\n    parentName: \"li\"\n  }, \"  For example, if Animal class has an eat() method and subclasses Cat and Dog override it.\"), mdx(\"p\", {\n    parentName: \"li\"\n  }, \"  eat(animal) will call the methods from either the class Cat or Dog, whichever it was before upcasting.\"), mdx(\"p\", {\n    parentName: \"li\"\n  }, \"  \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/Runtime-Polymorphism-or-Dynamic-Method-Dispatch\",\n    \"title\": \"Runtime Polymorphism or Dynamic Method Dispatch\"\n  }, \"[[Runtime Polymorphism or Dynamic Method Dispatch]]\"), \" is a result of Upcasting.\"))));\n}\n;\nMDXContent.isMDXComponent = true;","parent":{"__typename":"File","id":"8a489e2b-968e-5108-881a-143f7d83f8f3","fields":{"slug":"/Upcasting","title":"Upcasting"}}},{"__typename":"Mdx","body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"object-oriented-programming-moc\"\n  }, \"Object Oriented Programming MOC\"), mdx(\"h2\", {\n    \"id\": \"entitiescomponents\"\n  }, \"Entities/Components\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"[\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/notes/f30e6dc82b957fd005108e7423d340e2/Class.md\",\n    \"title\": \"Class\"\n  }, \"Class\"), \"]\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"[\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/notes/133b1a75530e8d8017b7b4922c3e1991/Object.md\",\n    \"title\": \"Object\"\n  }, \"Object\"), \"]\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"[\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/notes/37a08ba3f5f581b4a4331dff879cfb22/Friend%20Class.md\",\n    \"title\": \"Friend Class\"\n  }, \"Friend Class\"), \"]\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"[\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/notes/0cf2a234fd64adcbd51f98267976dfa4/Members%20of%20a%20Class.md\",\n    \"title\": \"Members of a Class\"\n  }, \"Members of a Class\"), \"]\")), mdx(\"h2\", {\n    \"id\": \"four-pillars--one-secret-basement-of-oop\"\n  }, \"Four Pillars + one secret basement of OOP\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"[\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/notes/845640eda3514c67160d3099d6c30163/Polymorphism.md\",\n    \"title\": \"Polymorphism\"\n  }, \"Polymorphism\"), \"]\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"[\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/notes/dc273c3092363fcefa7e110ae5047531/Inheritance.md\",\n    \"title\": \"Inheritance\"\n  }, \"Inheritance\"), \"]\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"[\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/notes/cf97fd81da8b35088ac552875e6ada4a/Encapsulation.md\",\n    \"title\": \"Encapsulation\"\n  }, \"Encapsulation\"), \"]\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"[\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/notes/0d417e9148d8dbb16540e61fb7b981b1/Abstraction.md\",\n    \"title\": \"Abstraction\"\n  }, \"Abstraction\"), \"]:\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/Interface-and-Abstract-Class\",\n    \"title\": \"Interface and Abstract Class\"\n  }, \"[[Interface and Abstract Class]]\"), \"\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/How-do-interface-and-abstract-class-achieve-abstraction\",\n    \"title\": \"How do interface and abstract class achieve abstraction\"\n  }, \"[[How do interface and abstract class achieve abstraction]]\"), \"\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/When-to-use-interface-and-when-to-use-abstract-class\",\n    \"title\": \"When to use interface and when to use abstract class\"\n  }, \"[[When to use interface and when to use abstract class]]\"), \"\"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"[\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/notes/1e5ebc0fa65d43aa7801bcb97c02e994/Association.md\",\n    \"title\": \"Association\"\n  }, \"Association\"), \"]\")), mdx(\"h2\", {\n    \"id\": \"oop-features\"\n  }, \"OOP Features\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"[\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/notes/2d23ba9cd2cb6686adc0fa4cac1c0bdb/Everything%20is%20an%20Object.md\",\n    \"title\": \"Everything is an Object\"\n  }, \"Everything is an Object\"), \"]\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"[\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/notes/c32fbb340ce8ac01ac640a1f672cbada/Method%20Overloading.md\",\n    \"title\": \"Method Overloading\"\n  }, \"Method Overloading\"), \"]\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"[\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/notes/f75922be6158cde5112b63f0eacf1d36/Method%20Overriding.md\",\n    \"title\": \"Method Overriding\"\n  }, \"Method Overriding\"), \"]\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"[\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/notes/f2f10eea4e3de3ce77e462a149c311e7/Static%20Binding.md\",\n    \"title\": \"Static Binding\"\n  }, \"Static Binding\"), \"]\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"[\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/notes/aa70e50bf86e49cc20cd2599f12bccc8/Dynamic%20Binding.md\",\n    \"title\": \"Dynamic Binding\"\n  }, \"Dynamic Binding\"), \"]\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"[\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/notes/b9a8ff8863713f933b3e1197a93ef18f/Runtime%20Polymorphism%20or%20Dynamic%20Method%20Dispatch.md\",\n    \"title\": \"Runtime Polymorphism or Dynamic Method Dispatch\"\n  }, \"Runtime Polymorphism or Dynamic Method Dispatch\"), \"]\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"[\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/notes/3a3e0e0dcbf725e754e29324809ba5c4/Shadowing%20or%20Hiding.md\",\n    \"title\": \"Shadowing or Hiding\"\n  }, \"Shadowing or Hiding\"), \"]\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"[\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/notes/e99ce9ba06e9e287575a58dc72dba3ce/Subsitutability.md\",\n    \"title\": \"Subsitutability\"\n  }, \"Subsitutability\"), \"]\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"[\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/notes/e2754bdb0d5ed4949b07e743aa635b4f/Variance.md\",\n    \"title\": \"Variance\"\n  }, \"Variance\"), \"]\")), mdx(\"h2\", {\n    \"id\": \"types-of-membersclasses\"\n  }, \"Types of members/classes\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"[\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/notes/ff96a12f267de1bce2358dfff6c8d05b/Static.md\",\n    \"title\": \"Static\"\n  }, \"Static\"), \"]\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"[\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/notes/cf79eb7caa7d69396c8bee86e7faf579/Final.md\",\n    \"title\": \"Final\"\n  }, \"Final\"), \"]\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"[\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/notes/2261a10059feec3be4c1cf1b3b4fdcbe/Abstract.md\",\n    \"title\": \"Abstract\"\n  }, \"Abstract\"), \"]\")), mdx(\"h2\", {\n    \"id\": \"accessingreferring-objects\"\n  }, \"Accessing/referring objects\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"[\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/notes/2249808c81ad5f7001cc34b554a66f56/Self-reference.md\",\n    \"title\": \"Self-reference\"\n  }, \"Self-reference\"), \"]\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"[\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/notes/5818aa43b39b7c58e03db9de03298a4b/super%20keyword.md\",\n    \"title\": \"super keyword\"\n  }, \"super keyword\"), \"]\")), mdx(\"h2\", {\n    \"id\": \"playing-with-objects\"\n  }, \"Playing with Objects\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"[\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/notes/bcda27fc8fef79a8c4be3c60fbe81e84/Object%20Cloning.md\",\n    \"title\": \"Object Cloning\"\n  }, \"Object Cloning\"), \"]\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"[\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/notes/c55cec16370b44188f7171f68d046759/Object%20Type%20Conversion.md\",\n    \"title\": \"Object Type Conversion\"\n  }, \"Object Type Conversion\"), \"]: [\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/notes/55623a6d32b3656183fdf47bf48e7d0d/Upcasting.md\",\n    \"title\": \"Upcasting\"\n  }, \"Upcasting\"), \"] | [\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/notes/2776914e52669c5f16a9012ab86fa0c3/Downcasting.md\",\n    \"title\": \"Downcasting\"\n  }, \"Downcasting\"), \"]\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"[\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/notes/90b944292ceb659e608380e9414f57dc/Serialization.md\",\n    \"title\": \"Serialization\"\n  }, \"Serialization\"), \"]\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"[\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/notes/82e1fb8301d2c8f18dea1d439ec209e3/Deserialization.md\",\n    \"title\": \"Deserialization\"\n  }, \"Deserialization\"), \"]\")), mdx(\"h2\", {\n    \"id\": \"object-oriented-design\"\n  }, \"Object Oriented Design\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"[\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/notes/1eab0755ac4c68bebf7fc40a3dfa0bb4/Design%20an%20application%20with%20no%20constraints.md\",\n    \"title\": \"Design an application with no constraints\"\n  }, \"Design an application with no constraints\"), \"]\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/When-to-use-interface-and-when-to-use-abstract-class\",\n    \"title\": \"When to use interface and when to use abstract class\"\n  }, \"[[When to use interface and when to use abstract class]]\"), \"\")));\n}\n;\nMDXContent.isMDXComponent = true;","parent":{"__typename":"File","id":"35140c21-6fd1-5cfe-8313-c67b2dd98ee1","fields":{"slug":"/001 Object Oriented Programming MOC","title":"Object Oriented Programming MOC"}}}]},"fields":{"slug":"/Polymorphism","title":"Polymorphism"}}},"pageContext":{"id":"fab4af7a-a13d-53f2-9d4c-b31485f9888b"}},"staticQueryHashes":["2098632890","2221750479","2468095761"]}