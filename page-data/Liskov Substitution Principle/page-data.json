{"componentChunkName":"component---node-modules-gatsby-theme-garden-src-templates-local-file-js","path":"/Liskov Substitution Principle","result":{"data":{"file":{"childMdx":{"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"liskov-substitution-principle\"\n  }, \"Liskov Substitution Principle\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"If B is a subtype of A, then objects of type A may be replaced with objects of type B (i.e., an object of type A may be substituted with any object of a subtype B) without altering any of the desirable properties of the program (correctness, task performed, etc.)\")), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"For instance, if the type Cat is a subtype of Animal, then an expression of type Cat should be substitutable wherever an expression of type Animal is used.\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"Behavior\"), \"\\nAnimal walks on four legs.\\nCat walks on four legs.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"Attribute\"), \"\\nAnimal has two eyes.\\nCat has two eyes.\")))));\n}\n;\nMDXContent.isMDXComponent = true;","outboundReferences":[],"inboundReferences":[{"__typename":"Mdx","body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"solid\"\n  }, \"SOLID\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Single Responsibility\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Open-Closed\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/Liskov-Substitution-Principle\",\n    \"title\": \"Liskov Substitution Principle\"\n  }, \"[[Liskov Substitution Principle]]\"), \"\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Interface Segregation\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Dependency Inversion\")), mdx(\"h2\", {\n    \"id\": \"references\"\n  }, \"References\"), mdx(\"p\", null, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://www.youtube.com/watch?v=4cVZvoFGJTU\"\n  }, \"Michael Feathers - the deep synergy between testability and good design\")));\n}\n;\nMDXContent.isMDXComponent = true;","parent":{"__typename":"File","id":"66d4fc79-ea65-5941-b3af-efc7a93a821d","fields":{"slug":"/SOLID","title":"SOLID"}}},{"__typename":"Mdx","body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"purpose-of-inheritance\"\n  }, \"Purpose of [\", mdx(\"a\", {\n    parentName: \"h1\",\n    \"href\": \"notes/Inheritance.md\",\n    \"title\": \"Inheritance\"\n  }, \"Inheritance\"), \"]\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"[\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"notes/Subtyping.md\",\n    \"title\": \"Subtyping\"\n  }, \"Subtyping\"), \"]: Also see \", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/Liskov-Substitution-Principle\",\n    \"title\": \"Liskov Substitution Principle\"\n  }, \"[[Liskov Substitution Principle]]\"), \"\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Straightforward \", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/open-recursion\",\n    \"title\": \"open recursion\"\n  }, \"[[open recursion]]\"), \"\"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"[\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"notes/Subclassing.md\",\n    \"title\": \"Subclassing\"\n  }, \"Subclassing\"), \"]: Straightforward Code reuse\")), mdx(\"h2\", {\n    \"id\": \"references\"\n  }, \"References\"), mdx(\"p\", null, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://stackoverflow.com/questions/49002/prefer-composition-over-inheritance\"\n  }, \"Prefer composition over inheritance? - Stack Overflow\")));\n}\n;\nMDXContent.isMDXComponent = true;","parent":{"__typename":"File","id":"808d108f-bf34-58ed-85f5-1f1ec0b5dbd1","fields":{"slug":"/Purpose of Inheritance","title":"Purpose of [[Inheritance]]"}}},{"__typename":"Mdx","body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"upcasting\"\n  }, \"Upcasting\"), mdx(\"p\", null, \"Casting from subclass to superclass\"), mdx(\"h2\", {\n    \"id\": \"syntax\"\n  }, \"Syntax\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Generally, \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/Implicit-Casting\",\n    \"title\": \"Implicit Casting\"\n  }, \"[[Implicit Casting]]\"), \". Why?\"), mdx(\"p\", {\n    parentName: \"li\"\n  }, \"=> Compiler knows that \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Cat\"), \" is an \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Animal.\"), \" \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/Liskov-Substitution-Principle\",\n    \"title\": \"Liskov Substitution Principle\"\n  }, \"[[Liskov Substitution Principle]]\"), \"\"))), mdx(\"h2\", {\n    \"id\": \"what-upcasting-gives-us\"\n  }, \"What upcasting gives us?\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/Polymorphism\",\n    \"title\": \"Polymorphism\"\n  }, \"[[Polymorphism]]\"), \"\"), mdx(\"p\", {\n    parentName: \"li\"\n  }, \"  Instead of using different methods for a common functionality in each of the sub classes, we can have a common method in the superclass for that functionality and all subclass objects will be casted implicitly.\"), mdx(\"p\", {\n    parentName: \"li\"\n  }, \"  Example - a feed(Animal animal) function to which we can pass objects of Cat and Dog classes \\u2192 feed(cat); feed(dog);\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/Method-Overriding\",\n    \"title\": \"Method Overriding\"\n  }, \"[[Method Overriding]]\"), \"\"), mdx(\"p\", {\n    parentName: \"li\"\n  }, \"  When an object is upcasted, it still can call overridden methods from its original class.\"), mdx(\"p\", {\n    parentName: \"li\"\n  }, \"  For example, if Animal class has an eat() method and subclasses Cat and Dog override it.\"), mdx(\"p\", {\n    parentName: \"li\"\n  }, \"  eat(animal) will call the methods from either the class Cat or Dog, whichever it was before upcasting.\"), mdx(\"p\", {\n    parentName: \"li\"\n  }, \"  \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/Runtime-Polymorphism-or-Dynamic-Method-Dispatch\",\n    \"title\": \"Runtime Polymorphism or Dynamic Method Dispatch\"\n  }, \"[[Runtime Polymorphism or Dynamic Method Dispatch]]\"), \" is a result of Upcasting.\"))));\n}\n;\nMDXContent.isMDXComponent = true;","parent":{"__typename":"File","id":"8a489e2b-968e-5108-881a-143f7d83f8f3","fields":{"slug":"/Upcasting","title":"Upcasting"}}},{"__typename":"Mdx","body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"subsitutability\"\n  }, \"Subsitutability\"), mdx(\"p\", null, \"We can replace an object of Animal type with object of Cat type.\"), mdx(\"p\", null, \"More formally \\u2014 \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/Liskov-Substitution-Principle\",\n    \"title\": \"Liskov Substitution Principle\"\n  }, \"[[Liskov Substitution Principle]]\"), \"\"));\n}\n;\nMDXContent.isMDXComponent = true;","parent":{"__typename":"File","id":"82b72941-76dc-5be2-9ca7-e79258a7eaa1","fields":{"slug":"/Subsitutability","title":"Subsitutability"}}}]},"fields":{"slug":"/Liskov Substitution Principle","title":"Liskov Substitution Principle"}}},"pageContext":{"id":"902ea555-79e4-5394-b4a1-fc95ccba1556"}},"staticQueryHashes":["2098632890","2221750479","2468095761"]}