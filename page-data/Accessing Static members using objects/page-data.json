{"componentChunkName":"component---node-modules-gatsby-theme-garden-src-templates-local-file-js","path":"/Accessing Static members using objects","result":{"data":{"file":{"childMdx":{"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"accessing-static-members-using-objects\"\n  }, \"Accessing \", mdx(\"a\", {\n    parentName: \"h1\",\n    \"href\": \"/Static\",\n    \"title\": \"Static\"\n  }, \"[[Static]]\"), \" members using objects\"), mdx(\"p\", null, \"Its possible to write f.classMethod(). It is legal but a bad idea, since it causes confusion. The instance is not important in case of class methods. Only the declared type of 'f' matters.\"), mdx(\"p\", null, \"Its better to write Foo.classMethod() or Bar.classMethod(). This not only makes it clear which class method you would like to call. But also, that it is indeed a class method which you're calling.\"), mdx(\"p\", null, \"Of course, all this could be avoided by simply trying to not overide your static methods. You know, because \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/Static-Methods-can't-be-overridden\",\n    \"title\": \"Static Methods can't be overridden\"\n  }, \"[[Static Methods can't be overridden]]\"), \"\"));\n}\n;\nMDXContent.isMDXComponent = true;","outboundReferences":[{"__typename":"Mdx","body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"static\"\n  }, \"Static\"), mdx(\"h2\", {\n    \"id\": \"ownership\"\n  }, \"Ownership\"), mdx(\"p\", null, \"Static members and methods are owned by the class itself, not any object.\"), mdx(\"h2\", {\n    \"id\": \"accessing\"\n  }, \"Accessing\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"You don't need to create an instance or object to access static members.\"), mdx(\"p\", {\n    parentName: \"li\"\n  }, \"  You can access them through class.\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/Accessing-Static-members-using-objects\",\n    \"title\": \"Accessing Static members using objects\"\n  }, \"[[Accessing Static members using objects]]\"), \"\"))), mdx(\"h2\", {\n    \"id\": \"initialization-in-program-memory\"\n  }, \"Initialization in program memory\"), mdx(\"p\", null, \"Static members are loaded into program memory along with the class. Even before initializing any objects.\"), mdx(\"h2\", {\n    \"id\": \"static-stuff\"\n  }, \"Static stuff\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/Static-Variable\",\n    \"title\": \"Static Variable\"\n  }, \"[[Static Variable]]\"), \"\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/Static-Method\",\n    \"title\": \"Static Method\"\n  }, \"[[Static Method]]\"), \"\")));\n}\n;\nMDXContent.isMDXComponent = true;","frontmatter":{"aliases":[]},"parent":{"__typename":"File","id":"74129eb0-ec7c-543b-90a6-646352220b79","fields":{"slug":"/Static","title":"Static"}}},{"__typename":"Mdx","body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"static-methods-cant-be-overridden\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"h1\",\n    \"href\": \"/Static-Method\",\n    \"title\": \"Static Method\"\n  }, \"[[Static Method]]\"), \"s can't be overridden\"), mdx(\"p\", null, \"You can't.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-java\"\n  }, \"//Can't do this -> Compile time error\\nclass Foo {\\n    public static void method() {\\n        System.out.println(\\\"in Foo\\\");\\n    }\\n}\\n \\nclass Bar extends Foo {\\n    public void method() {\\n        System.out.println(\\\"in Bar\\\");\\n    }\\n}\\n\")), mdx(\"p\", null, \"\", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/Why-compiler-sometimes-talks-about-overriding-static-methods\",\n    \"title\": \"Why compiler sometimes talks about overriding static methods\"\n  }, \"[[Why compiler sometimes talks about overriding static methods]]\"), \"\"));\n}\n;\nMDXContent.isMDXComponent = true;","frontmatter":{"aliases":[]},"parent":{"__typename":"File","id":"21b37855-cb1c-5d72-aaf6-824c6808b7d8","fields":{"slug":"/Static Methods can't be overridden","title":"[[Static Method]]s can't be overridden"}}}],"inboundReferences":[{"__typename":"Mdx","body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"static\"\n  }, \"Static\"), mdx(\"h2\", {\n    \"id\": \"ownership\"\n  }, \"Ownership\"), mdx(\"p\", null, \"Static members and methods are owned by the class itself, not any object.\"), mdx(\"h2\", {\n    \"id\": \"accessing\"\n  }, \"Accessing\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"You don't need to create an instance or object to access static members.\"), mdx(\"p\", {\n    parentName: \"li\"\n  }, \"  You can access them through class.\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/Accessing-Static-members-using-objects\",\n    \"title\": \"Accessing Static members using objects\"\n  }, \"[[Accessing Static members using objects]]\"), \"\"))), mdx(\"h2\", {\n    \"id\": \"initialization-in-program-memory\"\n  }, \"Initialization in program memory\"), mdx(\"p\", null, \"Static members are loaded into program memory along with the class. Even before initializing any objects.\"), mdx(\"h2\", {\n    \"id\": \"static-stuff\"\n  }, \"Static stuff\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/Static-Variable\",\n    \"title\": \"Static Variable\"\n  }, \"[[Static Variable]]\"), \"\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/Static-Method\",\n    \"title\": \"Static Method\"\n  }, \"[[Static Method]]\"), \"\")));\n}\n;\nMDXContent.isMDXComponent = true;","parent":{"__typename":"File","id":"74129eb0-ec7c-543b-90a6-646352220b79","fields":{"slug":"/Static","title":"Static"}}},{"__typename":"Mdx","body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"runtime-polymorphism-or-dynamic-method-dispatch----when-you-override---you-get-it----when-you-hide---you-dont\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"h1\",\n    \"href\": \"/Runtime-Polymorphism-or-Dynamic-Method-Dispatch\",\n    \"title\": \"Runtime Polymorphism or Dynamic Method Dispatch\"\n  }, \"[[Runtime Polymorphism or Dynamic Method Dispatch]]\"), \" -- When you override - you get it -- when you hide - you don't\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-java\"\n  }, \"class Foo {\\n    public static void classMethod() {\\n        System.out.println(\\\"classMethod() in Foo\\\");\\n    }\\n \\n    public void instanceMethod() {\\n        System.out.println(\\\"instanceMethod() in Foo\\\");\\n    }\\n}\\n \\nclass Bar extends Foo {\\n    public static void classMethod() {\\n        System.out.println(\\\"classMethod() in Bar\\\");\\n    }\\n \\n    public void instanceMethod() {\\n        System.out.println(\\\"instanceMethod() in Bar\\\");\\n    }\\n}\\n  \\npublic class Test {\\n    public static void main(String[] args) {\\n        Foo f = new Bar();\\n        f.instanceMethod();\\n        f.classMethod(); //*Accessing static method using object\\n    }\\n}\\n\")), mdx(\"p\", null, \"Output -\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-java\"\n  }, \"instanceMethod() in Bar\\nclassMethod() in Foo\\n\")), mdx(\"p\", null, \"We are using the same instance to access both the methods. But since one is overriding and the other is hiding, we see different behaviours.\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"In case of instance method-\"), mdx(\"p\", {\n    parentName: \"li\"\n  }, \"  At runtime, JVM uses the instance 'f' to determine which method to run.\"), mdx(\"p\", {\n    parentName: \"li\"\n  }, \"  JVM sees at runtime, that 'f' is actually an instance of Bar, so it calls the method in Bar rather than the one in Foo.\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"In case of class (static) method-\"), mdx(\"p\", {\n    parentName: \"li\"\n  }, \"  Since, its a static method, JVM doesn't expect or need any instance to invoke that method. Even if you provide it with an instance like we did here, it will simply ignore it. It will just see the declaration of that instance, determine the declared type of it to determine which method to call. All of this, at compile-time.\"), mdx(\"p\", {\n    parentName: \"li\"\n  }, \"  It doesn't matter when at runtime, its decided that f is actually an instance of Bar. That's what we mean when we say a static method does not have run-time polymorphism.\"), mdx(\"p\", {\n    parentName: \"li\"\n  }, \"  Because of this difference in behaviour in static and instance methods, we use different terms - \\\"overriding\\\" for instance methods and \\\"hiding\\\" for class methods.\"), mdx(\"p\", {\n    parentName: \"li\"\n  }, \"  And when we say, you can't override a static method, it means you can write the code that looks like a static method being overridden, but it won't behave like an overridden method.\"))), mdx(\"p\", null, \"*Notice that \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/Accessing-Static-members-using-objects\",\n    \"title\": \"Accessing Static members using objects\"\n  }, \"[[Accessing Static members using objects]]\"), \" is possible\"));\n}\n;\nMDXContent.isMDXComponent = true;","parent":{"__typename":"File","id":"a38389e7-ffbe-546e-9b73-844f4aeda1b1","fields":{"slug":"/Runtime Polymorphism -- When you override - you get it -- when you hide - you don't","title":"[[Runtime Polymorphism or Dynamic Method Dispatch]] -- When you override - you get it -- when you hide - you don't"}}}]},"fields":{"slug":"/Accessing Static members using objects","title":"Accessing [[Static]] members using objects"}}},"pageContext":{"id":"e866bee3-734c-5e25-8ef0-bb071693d7fe"}},"staticQueryHashes":["2098632890","2221750479","2468095761"]}