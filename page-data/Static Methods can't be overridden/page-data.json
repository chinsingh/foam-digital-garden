{"componentChunkName":"component---node-modules-gatsby-theme-garden-src-templates-local-file-js","path":"/Static Methods can't be overridden","result":{"data":{"file":{"childMdx":{"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"static-methods-cant-be-overridden\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"h1\",\n    \"href\": \"/Static-Method\",\n    \"title\": \"Static Method\"\n  }, \"[[Static Method]]\"), \"s can't be overridden\"), mdx(\"p\", null, \"You can't.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-java\"\n  }, \"//Can't do this -> Compile time error\\nclass Foo {\\n    public static void method() {\\n        System.out.println(\\\"in Foo\\\");\\n    }\\n}\\n \\nclass Bar extends Foo {\\n    public void method() {\\n        System.out.println(\\\"in Bar\\\");\\n    }\\n}\\n\")), mdx(\"p\", null, \"\", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/Why-compiler-sometimes-talks-about-overriding-static-methods\",\n    \"title\": \"Why compiler sometimes talks about overriding static methods\"\n  }, \"[[Why compiler sometimes talks about overriding static methods]]\"), \"\"));\n}\n;\nMDXContent.isMDXComponent = true;","outboundReferences":[{"__typename":"Mdx","body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"static-methods\"\n  }, \"Static Methods\"), mdx(\"p\", null, \"A static method\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"belongs to the class rather than the object of a class.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"can be invoked without the need for creating an instance of a class.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"can access static data member and can change the value of it.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"cannot be abstract because they can't be overridden.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/Static-Methods-can't-access-instance(non-static)-variables\",\n    \"title\": \"Static Methods can't access instance(non-static) variables\"\n  }, \"[[Static Methods can't access instance(non-static) variables]]\"), \"\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/Overriding-static-methods\",\n    \"title\": \"Overriding static methods\"\n  }, \"[[Overriding static methods]]\"), \"\")));\n}\n;\nMDXContent.isMDXComponent = true;","frontmatter":{"aliases":[]},"parent":{"__typename":"File","id":"86ceb8bc-89dd-580c-9ea0-5375f836dcef","fields":{"slug":"/Static Method","title":"Static Methods"}}},{"__typename":"Mdx","body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"why-compiler-sometimes-talks-about-overriding-static-methods\"\n  }, \"Why compiler sometimes talks about overriding static methods\"), mdx(\"p\", null, \"It means hiding.\"), mdx(\"h2\", {\n    \"id\": \"references\"\n  }, \"References\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://sanaulla.info/2008/02/29/overriding-vs-hiding/\"\n  }, \"Overriding v/s Hiding - sanaulla.info\"), mdx(\"blockquote\", {\n    parentName: \"li\"\n  }, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"Sometimes you will see error messages from the compiler that talk about overriding static methods. Apparently, whoever writes these particular messages has not read the Java Language Specification and does not know the difference between overriding and hiding. So they use incorrect and misleading terminology. Just ignore it. The Java Language Specification is very clear about the difference between overriding and hiding, even if the compiler messages are not. Just pretend that the compiler said \\\"hide\\\" rather than \\\"override\\\".\")))));\n}\n;\nMDXContent.isMDXComponent = true;","frontmatter":{"aliases":[]},"parent":{"__typename":"File","id":"b7c3dedb-4678-5e3e-b3ca-3781079d6fa8","fields":{"slug":"/Why compiler sometimes talks about overriding static methods","title":"Why compiler sometimes talks about overriding static methods"}}}],"inboundReferences":[{"__typename":"Mdx","body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"accessing-static-members-using-objects\"\n  }, \"Accessing \", mdx(\"a\", {\n    parentName: \"h1\",\n    \"href\": \"/Static\",\n    \"title\": \"Static\"\n  }, \"[[Static]]\"), \" members using objects\"), mdx(\"p\", null, \"Its possible to write f.classMethod(). It is legal but a bad idea, since it causes confusion. The instance is not important in case of class methods. Only the declared type of 'f' matters.\"), mdx(\"p\", null, \"Its better to write Foo.classMethod() or Bar.classMethod(). This not only makes it clear which class method you would like to call. But also, that it is indeed a class method which you're calling.\"), mdx(\"p\", null, \"Of course, all this could be avoided by simply trying to not overide your static methods. You know, because \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/Static-Methods-can't-be-overridden\",\n    \"title\": \"Static Methods can't be overridden\"\n  }, \"[[Static Methods can't be overridden]]\"), \"\"));\n}\n;\nMDXContent.isMDXComponent = true;","parent":{"__typename":"File","id":"e866bee3-734c-5e25-8ef0-bb071693d7fe","fields":{"slug":"/Accessing Static members using objects","title":"Accessing [[Static]] members using objects"}}},{"__typename":"Mdx","body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"interface-and-abstract-class\"\n  }, \"Interface and Abstract Class\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"Abstract class achieves partial abstraction (0 to 100%) and interface achieves full abstraction (100%)\")), mdx(\"table\", null, mdx(\"thead\", {\n    parentName: \"table\"\n  }, mdx(\"tr\", {\n    parentName: \"thead\"\n  }, mdx(\"th\", {\n    parentName: \"tr\",\n    \"align\": null\n  }), mdx(\"th\", {\n    parentName: \"tr\",\n    \"align\": null\n  }), mdx(\"th\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Abstract Class\"), mdx(\"th\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Interface\"))), mdx(\"tbody\", {\n    parentName: \"table\"\n  }, mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"\\uD83D\\uDFE2\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Types of Methods\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"can have abstract and non-abstract methods\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"can have only abstract methods. After java 8, can have default and static methods also.\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"\\uD83D\\uDFE2\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"[\", mdx(\"a\", {\n    parentName: \"td\",\n    \"href\": \"/notes/843e2469bb3cf78c4515e280bf041c42/Multiple%20Inheritance.md\",\n    \"title\": \"Multiple Inheritance\"\n  }, \"Multiple Inheritance\"), \"] Support\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Doesn't support multiple inheritance\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Supports multiple inheritance\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"\\uD83D\\uDFE2\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Types of variables\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Can have final, non-final, static, non-static variables\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Only static final variables\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Implementation of each other\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Can provide the implementation of interface\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Can't provide implementation of abstract class\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Keywords\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"- abstract keyword - extends keyword\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"- interface keyword - implements keyword\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Extending other classes and interface\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"can extend another class and implement multiple interface\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"can extend only other interfaces\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"\\uD83D\\uDFE2\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"Access level of members\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"class members can be private and protected also\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"members are public by default\")))), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"[\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/notes/dd31ce1550de3f35ac94750ed0587727/When%20to%20use%20interface%20and%20when%20to%20use%20abstract%20class.md\",\n    \"title\": \"When to use interface and when to use abstract class\"\n  }, \"When to use interface and when to use abstract class\"), \"]\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"[\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/notes/14f1a48e401096f03bc23fbaf6aa0168/How%20do%20interface%20and%20abstract%20class%20achieve%20abstraction.md\",\n    \"title\": \"How do Interface and Abstract Class achieve abstraction\"\n  }, \"How do interface and abstract class achieve abstraction\"), \"]\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Static methods cannot be abstract since \", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/Static-Methods-can't-be-overridden\",\n    \"title\": \"Static Methods can't be overridden\"\n  }, \"[[Static Methods can't be overridden]]\"), \"\")));\n}\n;\nMDXContent.isMDXComponent = true;","parent":{"__typename":"File","id":"b1ccbeab-cc76-5fcc-b0cb-cec7ff4ca150","fields":{"slug":"/Interface and Abstract Class","title":"Interface and Abstract Class"}}}]},"fields":{"slug":"/Static Methods can't be overridden","title":"[[Static Method]]s can't be overridden"}}},"pageContext":{"id":"21b37855-cb1c-5d72-aaf6-824c6808b7d8"}},"staticQueryHashes":["2098632890","2221750479","2468095761"]}