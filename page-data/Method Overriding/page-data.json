{"componentChunkName":"component---node-modules-gatsby-theme-garden-src-templates-local-file-js","path":"/Method Overriding","result":{"data":{"file":{"childMdx":{"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"method-overriding\"\n  }, \"Method Overriding\"), mdx(\"p\", null, \"When a child class has same method as that of a parent class, that method is said to override the parent's method.\"), mdx(\"h2\", {\n    \"id\": \"how-can-it-be-achieved\"\n  }, \"How can it be achieved?\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Method must have same name as parent\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Same parameter as parent\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Return type must be same or have an IS-A relationship with parent method's return type \", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/Covariant-Return-Types\",\n    \"title\": \"Covariant Return Types\"\n  }, \"[[Covariant Return Types]]\"), \".\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Overridden method should not be more restrictive than parent method.\")));\n}\n;\nMDXContent.isMDXComponent = true;","outboundReferences":[{"__typename":"Mdx","body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"covariant-return-types\"\n  }, \"Covariant Return Types\"), mdx(\"p\", null, \"Before Java 5 it wasn't possible to override a method based on its return type. Now, we can override a method if its return types are in the same direction as the subclass.\"), mdx(\"p\", null, \"Two examples where this can work -\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Suppose there are two classes A and B. A has a function with return type A and B has the function with the same name and arguments but with return type B. The function in B can override the one in A in this situation.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Suppose there are four classes A, B, C and D. A is inherited by C and B is inherited by D. Now C has a function with return type A and D has a method with same name and arguments with return type B. Method overriding works here.\")), mdx(\"p\", null, \"Basically, the parent return type is being replaced by child return type in the overriding method.\"));\n}\n;\nMDXContent.isMDXComponent = true;","frontmatter":{"aliases":[]},"parent":{"__typename":"File","id":"827f07d0-abbf-5a02-a34b-d2830bc66faf","fields":{"slug":"/Covariant Return Types","title":"Covariant Return Types"}}}],"inboundReferences":[{"__typename":"Mdx","body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"polymorphism\"\n  }, \"Polymorphism\"), mdx(\"h2\", {\n    \"id\": \"what-is-it\"\n  }, \"What is it?\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Many forms\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Methods with same name can be used for different purposes\")), mdx(\"h2\", {\n    \"id\": \"implemented-by\"\n  }, \"Implemented By\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/Method-Overloading\",\n    \"title\": \"Method Overloading\"\n  }, \"[[Method Overloading]]\"), \"\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/Method-Overriding\",\n    \"title\": \"Method Overriding\"\n  }, \"[[Method Overriding]]\"), \"\")), mdx(\"h2\", {\n    \"id\": \"why-polymorphism\"\n  }, \"Why Polymorphism?\"));\n}\n;\nMDXContent.isMDXComponent = true;","parent":{"__typename":"File","id":"fab4af7a-a13d-53f2-9d4c-b31485f9888b","fields":{"slug":"/Polymorphism","title":"Polymorphism"}}},{"__typename":"Mdx","body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"shadowing-or-hiding\"\n  }, \"Shadowing or Hiding\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Overriding\"), \" => In case of non-static methods\"), mdx(\"pre\", {\n    parentName: \"li\"\n  }, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-java\"\n  }, \"class A{\\n    public void show(){\\n    System.out.println(\\\"in A\\\");\\n    }\\n}\\n\\nclass B extends A{\\n    public void show(){\\n    System.out.println(\\\"in B\\\");\\n    }\\n}\\n\"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Hiding\"), \" => In case of all other members (instance members, static members, static methods)\"), mdx(\"pre\", {\n    parentName: \"li\"\n  }, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-java\"\n  }, \"class A{\\nint a;\\nstatic int b;\\nstatic meth();\\n}\\n\\nclass B extends A{\\nint a;\\nstatic int b;\\nstatic meth();\\n}\\n\\n//class B now has both properties.\\n//'a' from its own class\\n\")))), mdx(\"h2\", {\n    \"id\": \"major-difference-between-method-overriding-and-hiding\"\n  }, \"Major Difference between \", mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"/Method-Overriding\",\n    \"title\": \"Method Overriding\"\n  }, \"[[Method Overriding]]\"), \" and Hiding\"), mdx(\"p\", null, \"This\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-java\"\n  }, \"class Foo {\\n    public void method() {\\n        System.out.println(\\\"in Foo\\\");\\n    }\\n}\\n \\nclass Bar extends Foo {\\n    public void method() {\\n        System.out.println(\\\"in Bar\\\");\\n    }\\n}\\n\")), mdx(\"p\", null, \"is not the same as this\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-java\"\n  }, \"class Foo {\\n    public static void method() {\\n        System.out.println(\\\"in Foo\\\");\\n    }\\n}\\n \\nclass Bar extends Foo {\\n    public static void method() {\\n        System.out.println(\\\"in Bar\\\");\\n    }\\n}\\n\")), mdx(\"p\", null, \"Both the codes compile and run fine.\"), mdx(\"p\", null, \"But the second one isn't an example of one static method overriding another static method. Its an example of a static method hiding another static method.\"), mdx(\"p\", null, \"What's the difference?\"), mdx(\"p\", null, \"=> \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/Runtime-Polymorphism-When-you-override-you-get-it-when-you-hide-you-don't\",\n    \"title\": \"Runtime Polymorphism -- When you override - you get it -- when you hide - you don't\"\n  }, \"[[Runtime Polymorphism -- When you override - you get it -- when you hide - you don't]]\"), \"\"), mdx(\"p\", null, \"[\", \"[Why compiler sometimes talks about overriding static methods]\"));\n}\n;\nMDXContent.isMDXComponent = true;","parent":{"__typename":"File","id":"a8fe3a53-06b5-578e-bec8-c3bc35a7a2e2","fields":{"slug":"/Shadowing or Hiding","title":"Shadowing or Hiding"}}},{"__typename":"Mdx","body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"runtime-polymorphism-or-dynamic-method-dispatch\"\n  }, \"Runtime Polymorphism or Dynamic Method Dispatch\"), mdx(\"h2\", {\n    \"id\": \"method-overriding--dynamic-binding--runtime-polymorphism\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"/Method-Overriding\",\n    \"title\": \"Method Overriding\"\n  }, \"[[Method Overriding]]\"), \" + \", mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"/Dynamic-Binding\",\n    \"title\": \"Dynamic Binding\"\n  }, \"[[Dynamic Binding]]\"), \" = Runtime Polymorphism\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Method Overriding - Which Method to call depends on object type\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"++\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Dynamic Binding - Object type determined at runtime\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"=> Which method to call - decided at runtime\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"-> Runtime Polymorphism\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/Object-being-referred-to-determines-the-version-of-method-to-be-called\",\n    \"title\": \"Object being referred to determines the version of method to be called\"\n  }, \"[[Object being referred to determines the version of method to be called]]\"), \"\")), mdx(\"h2\", {\n    \"id\": \"references\"\n  }, \"References\"), mdx(\"p\", null, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://www.geeksforgeeks.org/dynamic-method-dispatch-runtime-polymorphism-java/\"\n  }, \"GFG - Dynamic Method Dispatch or Runtime Polymmorphism in Java\")));\n}\n;\nMDXContent.isMDXComponent = true;","parent":{"__typename":"File","id":"3ee24743-22de-5191-bc08-a2dda5ad44ce","fields":{"slug":"/Runtime Polymorphism or Dynamic Method Dispatch","title":"Runtime Polymorphism or Dynamic Method Dispatch"}}},{"__typename":"Mdx","body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"upcasting\"\n  }, \"Upcasting\"), mdx(\"p\", null, \"Casting from subclass to superclass\"), mdx(\"h2\", {\n    \"id\": \"syntax\"\n  }, \"Syntax\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Generally, \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/Implicit-Casting\",\n    \"title\": \"Implicit Casting\"\n  }, \"[[Implicit Casting]]\"), \". Why?\"), mdx(\"p\", {\n    parentName: \"li\"\n  }, \"=> Compiler knows that \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Cat\"), \" is an \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Animal.\"), \" \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/Liskov-Substitution-Principle\",\n    \"title\": \"Liskov Substitution Principle\"\n  }, \"[[Liskov Substitution Principle]]\"), \"\"))), mdx(\"h2\", {\n    \"id\": \"what-upcasting-gives-us\"\n  }, \"What upcasting gives us?\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/Polymorphism\",\n    \"title\": \"Polymorphism\"\n  }, \"[[Polymorphism]]\"), \"\"), mdx(\"p\", {\n    parentName: \"li\"\n  }, \"  Instead of using different methods for a common functionality in each of the sub classes, we can have a common method in the superclass for that functionality and all subclass objects will be casted implicitly.\"), mdx(\"p\", {\n    parentName: \"li\"\n  }, \"  Example - a feed(Animal animal) function to which we can pass objects of Cat and Dog classes \\u2192 feed(cat); feed(dog);\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/Method-Overriding\",\n    \"title\": \"Method Overriding\"\n  }, \"[[Method Overriding]]\"), \"\"), mdx(\"p\", {\n    parentName: \"li\"\n  }, \"  When an object is upcasted, it still can call overridden methods from its original class.\"), mdx(\"p\", {\n    parentName: \"li\"\n  }, \"  For example, if Animal class has an eat() method and subclasses Cat and Dog override it.\"), mdx(\"p\", {\n    parentName: \"li\"\n  }, \"  eat(animal) will call the methods from either the class Cat or Dog, whichever it was before upcasting.\"), mdx(\"p\", {\n    parentName: \"li\"\n  }, \"  \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/Runtime-Polymorphism-or-Dynamic-Method-Dispatch\",\n    \"title\": \"Runtime Polymorphism or Dynamic Method Dispatch\"\n  }, \"[[Runtime Polymorphism or Dynamic Method Dispatch]]\"), \" is a result of Upcasting.\"))));\n}\n;\nMDXContent.isMDXComponent = true;","parent":{"__typename":"File","id":"8a489e2b-968e-5108-881a-143f7d83f8f3","fields":{"slug":"/Upcasting","title":"Upcasting"}}},{"__typename":"Mdx","body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"object-oriented-programming-moc\"\n  }, \"Object Oriented Programming MOC\"), mdx(\"h2\", {\n    \"id\": \"entitiescomponents\"\n  }, \"Entities/Components\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"[\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/notes/f30e6dc82b957fd005108e7423d340e2/Class.md\",\n    \"title\": \"Class\"\n  }, \"Class\"), \"]\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"[\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/notes/133b1a75530e8d8017b7b4922c3e1991/Object.md\",\n    \"title\": \"Object\"\n  }, \"Object\"), \"]\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"[\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/notes/37a08ba3f5f581b4a4331dff879cfb22/Friend%20Class.md\",\n    \"title\": \"Friend Class\"\n  }, \"Friend Class\"), \"]\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"[\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/notes/0cf2a234fd64adcbd51f98267976dfa4/Members%20of%20a%20Class.md\",\n    \"title\": \"Members of a Class\"\n  }, \"Members of a Class\"), \"]\")), mdx(\"h2\", {\n    \"id\": \"four-pillars--one-secret-basement-of-oop\"\n  }, \"Four Pillars + one secret basement of OOP\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"[\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/notes/845640eda3514c67160d3099d6c30163/Polymorphism.md\",\n    \"title\": \"Polymorphism\"\n  }, \"Polymorphism\"), \"]\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"[\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/notes/dc273c3092363fcefa7e110ae5047531/Inheritance.md\",\n    \"title\": \"Inheritance\"\n  }, \"Inheritance\"), \"]\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"[\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/notes/cf97fd81da8b35088ac552875e6ada4a/Encapsulation.md\",\n    \"title\": \"Encapsulation\"\n  }, \"Encapsulation\"), \"]\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"[\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/notes/0d417e9148d8dbb16540e61fb7b981b1/Abstraction.md\",\n    \"title\": \"Abstraction\"\n  }, \"Abstraction\"), \"]:\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/Interface-and-Abstract-Class\",\n    \"title\": \"Interface and Abstract Class\"\n  }, \"[[Interface and Abstract Class]]\"), \"\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/How-do-interface-and-abstract-class-achieve-abstraction\",\n    \"title\": \"How do interface and abstract class achieve abstraction\"\n  }, \"[[How do interface and abstract class achieve abstraction]]\"), \"\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/When-to-use-interface-and-when-to-use-abstract-class\",\n    \"title\": \"When to use interface and when to use abstract class\"\n  }, \"[[When to use interface and when to use abstract class]]\"), \"\"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"[\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/notes/1e5ebc0fa65d43aa7801bcb97c02e994/Association.md\",\n    \"title\": \"Association\"\n  }, \"Association\"), \"]\")), mdx(\"h2\", {\n    \"id\": \"oop-features\"\n  }, \"OOP Features\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"[\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/notes/2d23ba9cd2cb6686adc0fa4cac1c0bdb/Everything%20is%20an%20Object.md\",\n    \"title\": \"Everything is an Object\"\n  }, \"Everything is an Object\"), \"]\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"[\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/notes/c32fbb340ce8ac01ac640a1f672cbada/Method%20Overloading.md\",\n    \"title\": \"Method Overloading\"\n  }, \"Method Overloading\"), \"]\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"[\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/notes/f75922be6158cde5112b63f0eacf1d36/Method%20Overriding.md\",\n    \"title\": \"Method Overriding\"\n  }, \"Method Overriding\"), \"]\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"[\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/notes/f2f10eea4e3de3ce77e462a149c311e7/Static%20Binding.md\",\n    \"title\": \"Static Binding\"\n  }, \"Static Binding\"), \"]\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"[\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/notes/aa70e50bf86e49cc20cd2599f12bccc8/Dynamic%20Binding.md\",\n    \"title\": \"Dynamic Binding\"\n  }, \"Dynamic Binding\"), \"]\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"[\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/notes/b9a8ff8863713f933b3e1197a93ef18f/Runtime%20Polymorphism%20or%20Dynamic%20Method%20Dispatch.md\",\n    \"title\": \"Runtime Polymorphism or Dynamic Method Dispatch\"\n  }, \"Runtime Polymorphism or Dynamic Method Dispatch\"), \"]\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"[\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/notes/3a3e0e0dcbf725e754e29324809ba5c4/Shadowing%20or%20Hiding.md\",\n    \"title\": \"Shadowing or Hiding\"\n  }, \"Shadowing or Hiding\"), \"]\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"[\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/notes/e99ce9ba06e9e287575a58dc72dba3ce/Subsitutability.md\",\n    \"title\": \"Subsitutability\"\n  }, \"Subsitutability\"), \"]\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"[\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/notes/e2754bdb0d5ed4949b07e743aa635b4f/Variance.md\",\n    \"title\": \"Variance\"\n  }, \"Variance\"), \"]\")), mdx(\"h2\", {\n    \"id\": \"types-of-membersclasses\"\n  }, \"Types of members/classes\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"[\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/notes/ff96a12f267de1bce2358dfff6c8d05b/Static.md\",\n    \"title\": \"Static\"\n  }, \"Static\"), \"]\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"[\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/notes/cf79eb7caa7d69396c8bee86e7faf579/Final.md\",\n    \"title\": \"Final\"\n  }, \"Final\"), \"]\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"[\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/notes/2261a10059feec3be4c1cf1b3b4fdcbe/Abstract.md\",\n    \"title\": \"Abstract\"\n  }, \"Abstract\"), \"]\")), mdx(\"h2\", {\n    \"id\": \"accessingreferring-objects\"\n  }, \"Accessing/referring objects\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"[\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/notes/2249808c81ad5f7001cc34b554a66f56/Self-reference.md\",\n    \"title\": \"Self-reference\"\n  }, \"Self-reference\"), \"]\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"[\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/notes/5818aa43b39b7c58e03db9de03298a4b/super%20keyword.md\",\n    \"title\": \"super keyword\"\n  }, \"super keyword\"), \"]\")), mdx(\"h2\", {\n    \"id\": \"playing-with-objects\"\n  }, \"Playing with Objects\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"[\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/notes/bcda27fc8fef79a8c4be3c60fbe81e84/Object%20Cloning.md\",\n    \"title\": \"Object Cloning\"\n  }, \"Object Cloning\"), \"]\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"[\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/notes/c55cec16370b44188f7171f68d046759/Object%20Type%20Conversion.md\",\n    \"title\": \"Object Type Conversion\"\n  }, \"Object Type Conversion\"), \"]: [\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/notes/55623a6d32b3656183fdf47bf48e7d0d/Upcasting.md\",\n    \"title\": \"Upcasting\"\n  }, \"Upcasting\"), \"] | [\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/notes/2776914e52669c5f16a9012ab86fa0c3/Downcasting.md\",\n    \"title\": \"Downcasting\"\n  }, \"Downcasting\"), \"]\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"[\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/notes/90b944292ceb659e608380e9414f57dc/Serialization.md\",\n    \"title\": \"Serialization\"\n  }, \"Serialization\"), \"]\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"[\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/notes/82e1fb8301d2c8f18dea1d439ec209e3/Deserialization.md\",\n    \"title\": \"Deserialization\"\n  }, \"Deserialization\"), \"]\")), mdx(\"h2\", {\n    \"id\": \"object-oriented-design\"\n  }, \"Object Oriented Design\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"[\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/notes/1eab0755ac4c68bebf7fc40a3dfa0bb4/Design%20an%20application%20with%20no%20constraints.md\",\n    \"title\": \"Design an application with no constraints\"\n  }, \"Design an application with no constraints\"), \"]\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/When-to-use-interface-and-when-to-use-abstract-class\",\n    \"title\": \"When to use interface and when to use abstract class\"\n  }, \"[[When to use interface and when to use abstract class]]\"), \"\")));\n}\n;\nMDXContent.isMDXComponent = true;","parent":{"__typename":"File","id":"35140c21-6fd1-5cfe-8313-c67b2dd98ee1","fields":{"slug":"/001 Object Oriented Programming MOC","title":"Object Oriented Programming MOC"}}}]},"fields":{"slug":"/Method Overriding","title":"Method Overriding"}}},"pageContext":{"id":"546d3fe8-8725-51c7-9b8e-54717c1046ee"}},"staticQueryHashes":["2098632890","2221750479","2468095761"]}