{"componentChunkName":"component---node-modules-gatsby-theme-garden-src-templates-local-file-js","path":"/Shadowing or Hiding","result":{"data":{"file":{"childMdx":{"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"shadowing-or-hiding\"\n  }, \"Shadowing or Hiding\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Overriding\"), \" => In case of non-static methods\"), mdx(\"pre\", {\n    parentName: \"li\"\n  }, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-java\"\n  }, \"class A{\\n    public void show(){\\n    System.out.println(\\\"in A\\\");\\n    }\\n}\\n\\nclass B extends A{\\n    public void show(){\\n    System.out.println(\\\"in B\\\");\\n    }\\n}\\n\"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Hiding\"), \" => In case of all other members (instance members, static members, static methods)\"), mdx(\"pre\", {\n    parentName: \"li\"\n  }, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-java\"\n  }, \"class A{\\nint a;\\nstatic int b;\\nstatic meth();\\n}\\n\\nclass B extends A{\\nint a;\\nstatic int b;\\nstatic meth();\\n}\\n\\n//class B now has both properties.\\n//'a' from its own class\\n\")))), mdx(\"h2\", {\n    \"id\": \"major-difference-between-method-overriding-and-hiding\"\n  }, \"Major Difference between \", mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"/Method-Overriding\",\n    \"title\": \"Method Overriding\"\n  }, \"[[Method Overriding]]\"), \" and Hiding\"), mdx(\"p\", null, \"This\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-java\"\n  }, \"class Foo {\\n    public void method() {\\n        System.out.println(\\\"in Foo\\\");\\n    }\\n}\\n \\nclass Bar extends Foo {\\n    public void method() {\\n        System.out.println(\\\"in Bar\\\");\\n    }\\n}\\n\")), mdx(\"p\", null, \"is not the same as this\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-java\"\n  }, \"class Foo {\\n    public static void method() {\\n        System.out.println(\\\"in Foo\\\");\\n    }\\n}\\n \\nclass Bar extends Foo {\\n    public static void method() {\\n        System.out.println(\\\"in Bar\\\");\\n    }\\n}\\n\")), mdx(\"p\", null, \"Both the codes compile and run fine.\"), mdx(\"p\", null, \"But the second one isn't an example of one static method overriding another static method. Its an example of a static method hiding another static method.\"), mdx(\"p\", null, \"What's the difference?\"), mdx(\"p\", null, \"=> \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/Runtime-Polymorphism-When-you-override-you-get-it-when-you-hide-you-don't\",\n    \"title\": \"Runtime Polymorphism -- When you override - you get it -- when you hide - you don't\"\n  }, \"[[Runtime Polymorphism -- When you override - you get it -- when you hide - you don't]]\"), \"\"), mdx(\"p\", null, \"[\", \"[Why compiler sometimes talks about overriding static methods]\"));\n}\n;\nMDXContent.isMDXComponent = true;","outboundReferences":[{"__typename":"Mdx","body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"method-overriding\"\n  }, \"Method Overriding\"), mdx(\"p\", null, \"When a child class has same method as that of a parent class, that method is said to override the parent's method.\"), mdx(\"h2\", {\n    \"id\": \"how-can-it-be-achieved\"\n  }, \"How can it be achieved?\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Method must have same name as parent\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Same parameter as parent\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Return type must be same or have an IS-A relationship with parent method's return type \", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/Covariant-Return-Types\",\n    \"title\": \"Covariant Return Types\"\n  }, \"[[Covariant Return Types]]\"), \".\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Overridden method should not be more restrictive than parent method.\")));\n}\n;\nMDXContent.isMDXComponent = true;","frontmatter":{"aliases":[]},"parent":{"__typename":"File","id":"546d3fe8-8725-51c7-9b8e-54717c1046ee","fields":{"slug":"/Method Overriding","title":"Method Overriding"}}},{"__typename":"Mdx","body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"runtime-polymorphism-or-dynamic-method-dispatch----when-you-override---you-get-it----when-you-hide---you-dont\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"h1\",\n    \"href\": \"/Runtime-Polymorphism-or-Dynamic-Method-Dispatch\",\n    \"title\": \"Runtime Polymorphism or Dynamic Method Dispatch\"\n  }, \"[[Runtime Polymorphism or Dynamic Method Dispatch]]\"), \" -- When you override - you get it -- when you hide - you don't\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-java\"\n  }, \"class Foo {\\n    public static void classMethod() {\\n        System.out.println(\\\"classMethod() in Foo\\\");\\n    }\\n \\n    public void instanceMethod() {\\n        System.out.println(\\\"instanceMethod() in Foo\\\");\\n    }\\n}\\n \\nclass Bar extends Foo {\\n    public static void classMethod() {\\n        System.out.println(\\\"classMethod() in Bar\\\");\\n    }\\n \\n    public void instanceMethod() {\\n        System.out.println(\\\"instanceMethod() in Bar\\\");\\n    }\\n}\\n  \\npublic class Test {\\n    public static void main(String[] args) {\\n        Foo f = new Bar();\\n        f.instanceMethod();\\n        f.classMethod(); //*Accessing static method using object\\n    }\\n}\\n\")), mdx(\"p\", null, \"Output -\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-java\"\n  }, \"instanceMethod() in Bar\\nclassMethod() in Foo\\n\")), mdx(\"p\", null, \"We are using the same instance to access both the methods. But since one is overriding and the other is hiding, we see different behaviours.\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"In case of instance method-\"), mdx(\"p\", {\n    parentName: \"li\"\n  }, \"  At runtime, JVM uses the instance 'f' to determine which method to run.\"), mdx(\"p\", {\n    parentName: \"li\"\n  }, \"  JVM sees at runtime, that 'f' is actually an instance of Bar, so it calls the method in Bar rather than the one in Foo.\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"In case of class (static) method-\"), mdx(\"p\", {\n    parentName: \"li\"\n  }, \"  Since, its a static method, JVM doesn't expect or need any instance to invoke that method. Even if you provide it with an instance like we did here, it will simply ignore it. It will just see the declaration of that instance, determine the declared type of it to determine which method to call. All of this, at compile-time.\"), mdx(\"p\", {\n    parentName: \"li\"\n  }, \"  It doesn't matter when at runtime, its decided that f is actually an instance of Bar. That's what we mean when we say a static method does not have run-time polymorphism.\"), mdx(\"p\", {\n    parentName: \"li\"\n  }, \"  Because of this difference in behaviour in static and instance methods, we use different terms - \\\"overriding\\\" for instance methods and \\\"hiding\\\" for class methods.\"), mdx(\"p\", {\n    parentName: \"li\"\n  }, \"  And when we say, you can't override a static method, it means you can write the code that looks like a static method being overridden, but it won't behave like an overridden method.\"))), mdx(\"p\", null, \"*Notice that \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/Accessing-Static-members-using-objects\",\n    \"title\": \"Accessing Static members using objects\"\n  }, \"[[Accessing Static members using objects]]\"), \" is possible\"));\n}\n;\nMDXContent.isMDXComponent = true;","frontmatter":{"aliases":[]},"parent":{"__typename":"File","id":"a38389e7-ffbe-546e-9b73-844f4aeda1b1","fields":{"slug":"/Runtime Polymorphism -- When you override - you get it -- when you hide - you don't","title":"[[Runtime Polymorphism or Dynamic Method Dispatch]] -- When you override - you get it -- when you hide - you don't"}}}],"inboundReferences":[{"__typename":"Mdx","body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"object-oriented-programming-moc\"\n  }, \"Object Oriented Programming MOC\"), mdx(\"h2\", {\n    \"id\": \"entitiescomponents\"\n  }, \"Entities/Components\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"[\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/notes/f30e6dc82b957fd005108e7423d340e2/Class.md\",\n    \"title\": \"Class\"\n  }, \"Class\"), \"]\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"[\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/notes/133b1a75530e8d8017b7b4922c3e1991/Object.md\",\n    \"title\": \"Object\"\n  }, \"Object\"), \"]\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"[\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/notes/37a08ba3f5f581b4a4331dff879cfb22/Friend%20Class.md\",\n    \"title\": \"Friend Class\"\n  }, \"Friend Class\"), \"]\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"[\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/notes/0cf2a234fd64adcbd51f98267976dfa4/Members%20of%20a%20Class.md\",\n    \"title\": \"Members of a Class\"\n  }, \"Members of a Class\"), \"]\")), mdx(\"h2\", {\n    \"id\": \"four-pillars--one-secret-basement-of-oop\"\n  }, \"Four Pillars + one secret basement of OOP\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"[\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/notes/845640eda3514c67160d3099d6c30163/Polymorphism.md\",\n    \"title\": \"Polymorphism\"\n  }, \"Polymorphism\"), \"]\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"[\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/notes/dc273c3092363fcefa7e110ae5047531/Inheritance.md\",\n    \"title\": \"Inheritance\"\n  }, \"Inheritance\"), \"]\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"[\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/notes/cf97fd81da8b35088ac552875e6ada4a/Encapsulation.md\",\n    \"title\": \"Encapsulation\"\n  }, \"Encapsulation\"), \"]\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"[\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/notes/0d417e9148d8dbb16540e61fb7b981b1/Abstraction.md\",\n    \"title\": \"Abstraction\"\n  }, \"Abstraction\"), \"]:\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/Interface-and-Abstract-Class\",\n    \"title\": \"Interface and Abstract Class\"\n  }, \"[[Interface and Abstract Class]]\"), \"\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/How-do-interface-and-abstract-class-achieve-abstraction\",\n    \"title\": \"How do interface and abstract class achieve abstraction\"\n  }, \"[[How do interface and abstract class achieve abstraction]]\"), \"\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/When-to-use-interface-and-when-to-use-abstract-class\",\n    \"title\": \"When to use interface and when to use abstract class\"\n  }, \"[[When to use interface and when to use abstract class]]\"), \"\"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"[\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/notes/1e5ebc0fa65d43aa7801bcb97c02e994/Association.md\",\n    \"title\": \"Association\"\n  }, \"Association\"), \"]\")), mdx(\"h2\", {\n    \"id\": \"oop-features\"\n  }, \"OOP Features\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"[\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/notes/2d23ba9cd2cb6686adc0fa4cac1c0bdb/Everything%20is%20an%20Object.md\",\n    \"title\": \"Everything is an Object\"\n  }, \"Everything is an Object\"), \"]\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"[\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/notes/c32fbb340ce8ac01ac640a1f672cbada/Method%20Overloading.md\",\n    \"title\": \"Method Overloading\"\n  }, \"Method Overloading\"), \"]\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"[\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/notes/f75922be6158cde5112b63f0eacf1d36/Method%20Overriding.md\",\n    \"title\": \"Method Overriding\"\n  }, \"Method Overriding\"), \"]\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"[\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/notes/f2f10eea4e3de3ce77e462a149c311e7/Static%20Binding.md\",\n    \"title\": \"Static Binding\"\n  }, \"Static Binding\"), \"]\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"[\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/notes/aa70e50bf86e49cc20cd2599f12bccc8/Dynamic%20Binding.md\",\n    \"title\": \"Dynamic Binding\"\n  }, \"Dynamic Binding\"), \"]\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"[\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/notes/b9a8ff8863713f933b3e1197a93ef18f/Runtime%20Polymorphism%20or%20Dynamic%20Method%20Dispatch.md\",\n    \"title\": \"Runtime Polymorphism or Dynamic Method Dispatch\"\n  }, \"Runtime Polymorphism or Dynamic Method Dispatch\"), \"]\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"[\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/notes/3a3e0e0dcbf725e754e29324809ba5c4/Shadowing%20or%20Hiding.md\",\n    \"title\": \"Shadowing or Hiding\"\n  }, \"Shadowing or Hiding\"), \"]\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"[\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/notes/e99ce9ba06e9e287575a58dc72dba3ce/Subsitutability.md\",\n    \"title\": \"Subsitutability\"\n  }, \"Subsitutability\"), \"]\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"[\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/notes/e2754bdb0d5ed4949b07e743aa635b4f/Variance.md\",\n    \"title\": \"Variance\"\n  }, \"Variance\"), \"]\")), mdx(\"h2\", {\n    \"id\": \"types-of-membersclasses\"\n  }, \"Types of members/classes\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"[\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/notes/ff96a12f267de1bce2358dfff6c8d05b/Static.md\",\n    \"title\": \"Static\"\n  }, \"Static\"), \"]\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"[\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/notes/cf79eb7caa7d69396c8bee86e7faf579/Final.md\",\n    \"title\": \"Final\"\n  }, \"Final\"), \"]\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"[\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/notes/2261a10059feec3be4c1cf1b3b4fdcbe/Abstract.md\",\n    \"title\": \"Abstract\"\n  }, \"Abstract\"), \"]\")), mdx(\"h2\", {\n    \"id\": \"accessingreferring-objects\"\n  }, \"Accessing/referring objects\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"[\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/notes/2249808c81ad5f7001cc34b554a66f56/Self-reference.md\",\n    \"title\": \"Self-reference\"\n  }, \"Self-reference\"), \"]\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"[\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/notes/5818aa43b39b7c58e03db9de03298a4b/super%20keyword.md\",\n    \"title\": \"super keyword\"\n  }, \"super keyword\"), \"]\")), mdx(\"h2\", {\n    \"id\": \"playing-with-objects\"\n  }, \"Playing with Objects\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"[\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/notes/bcda27fc8fef79a8c4be3c60fbe81e84/Object%20Cloning.md\",\n    \"title\": \"Object Cloning\"\n  }, \"Object Cloning\"), \"]\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"[\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/notes/c55cec16370b44188f7171f68d046759/Object%20Type%20Conversion.md\",\n    \"title\": \"Object Type Conversion\"\n  }, \"Object Type Conversion\"), \"]: [\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/notes/55623a6d32b3656183fdf47bf48e7d0d/Upcasting.md\",\n    \"title\": \"Upcasting\"\n  }, \"Upcasting\"), \"] | [\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/notes/2776914e52669c5f16a9012ab86fa0c3/Downcasting.md\",\n    \"title\": \"Downcasting\"\n  }, \"Downcasting\"), \"]\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"[\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/notes/90b944292ceb659e608380e9414f57dc/Serialization.md\",\n    \"title\": \"Serialization\"\n  }, \"Serialization\"), \"]\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"[\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/notes/82e1fb8301d2c8f18dea1d439ec209e3/Deserialization.md\",\n    \"title\": \"Deserialization\"\n  }, \"Deserialization\"), \"]\")), mdx(\"h2\", {\n    \"id\": \"object-oriented-design\"\n  }, \"Object Oriented Design\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"[\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/notes/1eab0755ac4c68bebf7fc40a3dfa0bb4/Design%20an%20application%20with%20no%20constraints.md\",\n    \"title\": \"Design an application with no constraints\"\n  }, \"Design an application with no constraints\"), \"]\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/When-to-use-interface-and-when-to-use-abstract-class\",\n    \"title\": \"When to use interface and when to use abstract class\"\n  }, \"[[When to use interface and when to use abstract class]]\"), \"\")));\n}\n;\nMDXContent.isMDXComponent = true;","parent":{"__typename":"File","id":"35140c21-6fd1-5cfe-8313-c67b2dd98ee1","fields":{"slug":"/001 Object Oriented Programming MOC","title":"Object Oriented Programming MOC"}}}]},"fields":{"slug":"/Shadowing or Hiding","title":"Shadowing or Hiding"}}},"pageContext":{"id":"a8fe3a53-06b5-578e-bec8-c3bc35a7a2e2"}},"staticQueryHashes":["2098632890","2221750479","2468095761"]}