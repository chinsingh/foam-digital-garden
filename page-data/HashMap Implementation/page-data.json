{"componentChunkName":"component---node-modules-gatsby-theme-garden-src-templates-local-file-js","path":"/HashMap Implementation","result":{"data":{"file":{"childMdx":{"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"hashmap-implementation\"\n  }, \"HashMap Implementation\"), mdx(\"p\", null, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://www.youtube.com/watch?v=c3RVW3KGIIE\"\n  }, \"How HashMap works in Java? With Animation!! whats new in java8 tutorial\")), mdx(\"p\", null, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://dzone.com/articles/java8-hashmap-implementation-and-performance\"\n  }, \"Java 8 HashMap Implementation and Performance - DZone Java\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-java\"\n  }, \"HashMap <K,V> implements Map<K,V>\\n{\\nEntry <K,V> {} //Inner class\\nEntry next; //reference to another entry to store entries like linked lists\\n\\nint hash; //Hashvalue of key to avoid calculating everytime its  needed\\n}\\n\")), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Initial Capacity\"), mdx(\"p\", {\n    parentName: \"li\"\n  }, \"  16 (Array of 0-15)\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Load factor - After the load factor (percentage) is reached, the capacity automatically increases\"), mdx(\"p\", {\n    parentName: \"li\"\n  }, \"  0.75\"), mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"So when the array is filled more than 75%, the table size doubles to 32.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"The hashtable is rehashed (Internal data structures are rebuit)\"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"Java 8 improvement\"), mdx(\"p\", {\n    parentName: \"li\"\n  }, \"  When the number of nodes in a HashMap reaches the TREEIFY_THRESHOLD, the nodes are converted to TreeNode. Basically, from linked list to a balanced tree. This improves the worst case performance from O(n) to O(log n). After the HashMap becomes small due to removal or resizing, TreeNodes are converted back to nodes.\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, \"HashMap Bucket Resizing Overhead\"), mdx(\"p\", {\n    parentName: \"li\"\n  }, \"  You should create HashMap with initial capacity close to your expected volume. If its too small, and the load is in millions, whenever the bucket will reach its load factor it will resize and rehash \\u2192 which is a very costly operation. Also, make sure to use full capacity else a lot of memory of unused blocks will go wasted.\"))));\n}\n;\nMDXContent.isMDXComponent = true;","outboundReferences":[],"inboundReferences":[{"__typename":"Mdx","body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"hashmap\"\n  }, \"HashMap\"), mdx(\"p\", null, \"implements \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/Map\",\n    \"title\": \"Map\"\n  }, \"[[Map]]\"), \"\"), mdx(\"h2\", {\n    \"id\": \"initialization\"\n  }, \"Initialization\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-java\"\n  }, \"Map map = new HashMap();\\n\")), mdx(\"p\", null, \"or\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-java\"\n  }, \"Map<String, String> map = new HashMap<String, String>();\\n\")), mdx(\"h2\", {\n    \"id\": \"methods\"\n  }, \"Methods\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"map.put(\\\"key\\\", \\\"value\\\");\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"map.get(\\\"key\\\");\"), \" \\u2192 value\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"keySet()\"), \" \\u2192 Set of keys\")), mdx(\"p\", null, \"What happens when Repeating/duplicate keys \\u21D2 value gets replaced\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Fixed Order insertion \\u2192 Linked HashMap\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Sorting Order \\u2192 Tree HashMap\")), mdx(\"p\", null, \"\", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/HashMap-Implementation\",\n    \"title\": \"HashMap Implementation\"\n  }, \"[[HashMap Implementation]]\"), \"\"));\n}\n;\nMDXContent.isMDXComponent = true;","parent":{"__typename":"File","id":"e4ea5e86-b5ad-506e-b71f-f3dea306b553","fields":{"slug":"/HashMap","title":"HashMap"}}}]},"fields":{"slug":"/HashMap Implementation","title":"HashMap Implementation"}}},"pageContext":{"id":"95acab07-4ab4-5837-b2e7-b427e5c21c1e"}},"staticQueryHashes":["2098632890","2221750479","2468095761"]}